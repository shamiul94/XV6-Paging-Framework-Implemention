commit 86e0d6a6921bd85358cdf182292bbfe2c01c3b7a
Author: shamiul94 <1505038.sh@ugrad.cse.buet.ac.bd>
Date:   Sun Feb 10 21:50:41 2019 +0600

    final commit

diff --git a/Makefile b/Makefile
index 09d790c..2c08639 100644
--- a/Makefile
+++ b/Makefile
@@ -76,7 +76,7 @@ AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -157,7 +157,7 @@ _forktest: forktest.o $(ULIB)
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
-	gcc -Werror -Wall -o mkfs mkfs.c
+	gcc -Wall -o mkfs mkfs.c
 
 # Prevent deletion of intermediate files, e.g. cat.o, after first build, so
 # that disk image changes after first build are persistent until clean.  More
@@ -179,6 +179,8 @@ UPROGS=\
 	_sh\
 	_stressfs\
 	_usertests\
+	_memtest\
+	_pagingUser\
 	_wc\
 	_zombie\
 
@@ -249,7 +251,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c memtest.c pagingUser.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/defs.h b/defs.h
index 82fb982..b249780 100644
--- a/defs.h
+++ b/defs.h
@@ -53,6 +53,12 @@ int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
 
+// swap file functions by sir's patch
+int             createSwapFile(struct proc* p);
+int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
+int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
+int             removeSwapFile(struct proc* p);
+
 // ide.c
 void            ideinit(void);
 void            ideintr(void);
@@ -124,6 +130,11 @@ void            yield(void);
 // swtch.S
 void            swtch(struct context**, struct context*);
 
+// sysfile
+struct inode*   create(char *path, short type, short major, short minor);
+int             isdirempty(struct inode *dp);
+
+
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -171,6 +182,10 @@ void            uartintr(void);
 void            uartputc(int);
 
 // vm.c
+
+void 			isProcessAccessed();
+void            pageSwap(uint);
+
 void            seginit(void);
 void            kvmalloc(void);
 pde_t*          setupkvm(void);
@@ -187,4 +202,4 @@ int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
 
 // number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+#define NUMBERofELEMENT(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/exec.c b/exec.c
index b40134f..5f9ab5b 100644
--- a/exec.c
+++ b/exec.c
@@ -7,108 +7,186 @@
 #include "x86.h"
 #include "elf.h"
 
+int NUM_PAGES_IN_MEMORY, NUM_PAGES_IN_SWAP_FILE, NUM_TOTAL_PAGE_FAULT, NUM_TOTAL_PAGED_OUT;
+struct freePage FREE_PAGES[MAX_PSYC_PAGES];
+struct pageInfo SWAPPED_PAGES[MAX_PSYC_PAGES];
+
+
+void executeExecOperation(struct proc *curr) {
+    removeSwapFile(curr);
+    createSwapFile(curr);
+}
+
+void keepBackUp(struct proc *curproc){
+    NUM_PAGES_IN_MEMORY = curproc->NUM_PAGES_IN_MEMORY;
+    NUM_PAGES_IN_SWAP_FILE = curproc->NUM_PAGES_IN_SWAP_FILE;
+    NUM_TOTAL_PAGE_FAULT = curproc->NUM_TOTAL_PAGE_FAULT;
+    NUM_TOTAL_PAGED_OUT = curproc->NUM_TOTAL_PAGED_OUT;
+
+    int i;
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        FREE_PAGES[i].va = curproc->FREE_PAGES[i].va;
+        curproc->FREE_PAGES[i].va = (char *) 0xffffffff;
+        FREE_PAGES[i].next = curproc->FREE_PAGES[i].next;
+        curproc->FREE_PAGES[i].next = 0;
+        FREE_PAGES[i].prev = curproc->FREE_PAGES[i].prev;
+        curproc->FREE_PAGES[i].prev = 0;
+        SWAPPED_PAGES[i].va = curproc->SWAPPED_PAGES[i].va;
+        curproc->SWAPPED_PAGES[i].va = (char *) 0xffffffff;
+        SWAPPED_PAGES[i].swaploc = curproc->SWAPPED_PAGES[i].swaploc;
+        curproc->SWAPPED_PAGES[i].swaploc = 0;
+    }
+
+}
+
+
+void restorePageDetails(struct proc *curproc, struct freePage *head, struct freePage *tail){
+    curproc->NUM_PAGES_IN_MEMORY = NUM_PAGES_IN_MEMORY;
+    curproc->NUM_PAGES_IN_SWAP_FILE = NUM_PAGES_IN_SWAP_FILE;
+    curproc->NUM_TOTAL_PAGE_FAULT = NUM_TOTAL_PAGE_FAULT;
+    curproc->NUM_TOTAL_PAGED_OUT = NUM_TOTAL_PAGED_OUT;
+    curproc->head = head;
+    curproc->tail = tail;
+
+    int i ;
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        curproc->FREE_PAGES[i].va = FREE_PAGES[i].va;
+        curproc->FREE_PAGES[i].next = FREE_PAGES[i].next;
+        curproc->FREE_PAGES[i].prev = FREE_PAGES[i].prev;
+        curproc->SWAPPED_PAGES[i].va = SWAPPED_PAGES[i].va;
+        curproc->SWAPPED_PAGES[i].swaploc = SWAPPED_PAGES[i].swaploc;
+    }
+}
+
 int
-exec(char *path, char **argv)
-{
-  char *s, *last;
-  int i, off;
-  uint argc, sz, sp, ustack[3+MAXARG+1];
-  struct elfhdr elf;
-  struct inode *ip;
-  struct proghdr ph;
-  pde_t *pgdir, *oldpgdir;
-  struct proc *curproc = myproc();
-
-  begin_op();
-
-  if((ip = namei(path)) == 0){
-    end_op();
-    cprintf("exec: fail\n");
-    return -1;
-  }
-  ilock(ip);
-  pgdir = 0;
-
-  // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
-    goto bad;
-  if(elf.magic != ELF_MAGIC)
-    goto bad;
-
-  if((pgdir = setupkvm()) == 0)
-    goto bad;
-
-  // Load program into memory.
-  sz = 0;
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
-      goto bad;
-    if(ph.type != ELF_PROG_LOAD)
-      continue;
-    if(ph.memsz < ph.filesz)
-      goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)
-      goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
-      goto bad;
-    if(ph.vaddr % PGSIZE != 0)
-      goto bad;
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
-      goto bad;
-  }
-  iunlockput(ip);
-  end_op();
-  ip = 0;
-
-  // Allocate two pages at the next page boundary.
-  // Make the first inaccessible.  Use the second as the user stack.
-  sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
-    goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-  sp = sz;
-
-  // Push argument strings, prepare rest of stack in ustack.
-  for(argc = 0; argv[argc]; argc++) {
-    if(argc >= MAXARG)
-      goto bad;
-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-      goto bad;
-    ustack[3+argc] = sp;
-  }
-  ustack[3+argc] = 0;
-
-  ustack[0] = 0xffffffff;  // fake return PC
-  ustack[1] = argc;
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
-
-  sp -= (3+argc+1) * 4;
-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
-    goto bad;
-
-  // Save program name for debugging.
-  for(last=s=path; *s; s++)
-    if(*s == '/')
-      last = s+1;
-  safestrcpy(curproc->name, last, sizeof(curproc->name));
-
-  // Commit to the user image.
-  oldpgdir = curproc->pgdir;
-  curproc->pgdir = pgdir;
-  curproc->sz = sz;
-  curproc->tf->eip = elf.entry;  // main
-  curproc->tf->esp = sp;
-  switchuvm(curproc);
-  freevm(oldpgdir);
-  return 0;
-
- bad:
-  if(pgdir)
-    freevm(pgdir);
-  if(ip){
+exec(char *path, char **argv) {
+    char *s, *last;
+    int i, off;
+    uint argc, sz, sp, ustack[3 + MAXARG + 1];
+    struct elfhdr elf;
+    struct inode *ip;
+    struct proghdr ph;
+    pde_t *pgdir, *oldpgdir;
+    struct proc *curproc = myproc();
+
+    begin_op();
+
+    if ((ip = namei(path)) == 0) {
+        end_op();
+        cprintf("exec: fail\n");
+        return -1;
+    }
+    ilock(ip);
+    pgdir = 0;
+
+    // Check ELF header
+    if (readi(ip, (char *) &elf, 0, sizeof(elf)) != sizeof(elf))
+        goto bad;
+    if (elf.magic != ELF_MAGIC)
+        goto bad;
+
+    if ((pgdir = setupkvm()) == 0)
+        goto bad;
+
+
+    // backup and reset proc fields
+
+    //TODO delete   cprintf("EXEC: NONE undefined (proc = %s)- backing up page info \n", proc->name);
+
+
+    keepBackUp(curproc);
+
+    struct freePage *head = curproc->head;
+    struct freePage *tail = curproc->tail;
+    curproc->NUM_PAGES_IN_MEMORY = 0;
+    curproc->NUM_PAGES_IN_SWAP_FILE = 0;
+    curproc->NUM_TOTAL_PAGE_FAULT = 0;
+    curproc->NUM_TOTAL_PAGED_OUT = 0;
+    curproc->head = 0;
+    curproc->tail = 0;
+
+    // Load program into memory.
+    sz = 0;
+    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
+        if (readi(ip, (char *) &ph, off, sizeof(ph)) != sizeof(ph))
+            goto bad;
+        if (ph.type != ELF_PROG_LOAD)
+            continue;
+        if (ph.memsz < ph.filesz)
+            goto bad;
+        if (ph.vaddr + ph.memsz < ph.vaddr)
+            goto bad;
+        if ((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+            goto bad;
+        if (ph.vaddr % PGSIZE != 0)
+            goto bad;
+        if (loaduvm(pgdir, (char *) ph.vaddr, ip, ph.off, ph.filesz) < 0)
+            goto bad;
+    }
     iunlockput(ip);
     end_op();
-  }
-  return -1;
+    ip = 0;
+
+    // Allocate two pages at the next page boundary.
+    // Make the first inaccessible.  Use the second as the user stack.
+    sz = PGROUNDUP(sz);
+    if ((sz = allocuvm(pgdir, sz, sz + 2 * PGSIZE)) == 0)
+        goto bad;
+    clearpteu(pgdir, (char *) (sz - 2 * PGSIZE));
+    sp = sz;
+
+    // Push argument strings, prepare rest of stack in ustack.
+    for (argc = 0; argv[argc]; argc++) {
+        if (argc >= MAXARG)
+            goto bad;
+        sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+        if (copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+            goto bad;
+        ustack[3 + argc] = sp;
+    }
+    ustack[3 + argc] = 0;
+
+    ustack[0] = 0xffffffff;  // fake return PC
+    ustack[1] = argc;
+    ustack[2] = sp - (argc + 1) * 4;  // argv pointer
+
+    sp -= (3 + argc + 1) * 4;
+    if (copyout(pgdir, sp, ustack, (3 + argc + 1) * 4) < 0)
+        goto bad;
+
+    // Save program name for debugging.
+    for (last = s = path; *s; s++)
+        if (*s == '/')
+            last = s + 1;
+    safestrcpy(curproc->name, last, sizeof(curproc->name));
+
+    // Commit to the user image.
+    oldpgdir = curproc->pgdir;
+    curproc->pgdir = pgdir;
+    curproc->sz = sz;
+    curproc->tf->eip = elf.entry;  // main
+    curproc->tf->esp = sp;
+
+    executeExecOperation(curproc);
+
+    switchuvm(curproc);
+    freevm(oldpgdir);
+
+    cprintf("no. of pages allocated on exec:%d, pid:%d, name:%s\n", curproc->NUM_PAGES_IN_MEMORY, curproc->pid, curproc->name);
+
+    return 0;
+
+    bad:
+    if (pgdir)
+        freevm(pgdir);
+    if (ip) {
+        iunlockput(ip);
+        end_op();
+    }
+
+    restorePageDetails(curproc, head, tail);
+
+    return -1;
 }
+
+
diff --git a/file.c b/file.c
index 24b32c2..ffda61e 100644
--- a/file.c
+++ b/file.c
@@ -9,6 +9,7 @@
 #include "spinlock.h"
 #include "sleeplock.h"
 #include "file.h"
+#include "selection.h"
 
 struct devsw devsw[NDEV];
 struct {
@@ -152,6 +153,8 @@ filewrite(struct file *f, char *addr, int n)
     }
     return i == n ? n : -1;
   }
-  panic("filewrite");
+    cprintf("Nayeem - %d, %d\n", f->type, FD_INODE);
+
+    panic("filewrite");
 }
 
diff --git a/fs.c b/fs.c
index feb59fe..f7c92cf 100644
--- a/fs.c
+++ b/fs.c
@@ -669,3 +669,144 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+// NEW FOR PAGING
+
+#include "fcntl.h"
+#define DIGITS 14
+
+char* itoa(int i, char b[]){
+    char const digit[] = "0123456789";
+    char* p = b;
+    if(i<0){
+        *p++ = '-';
+        i *= -1;
+    }
+    int shifter = i;
+    do{ //Move to where representation ends
+        ++p;
+        shifter = shifter/10;
+    }while(shifter);
+    *p = '\0';
+    do{ //Move back, inserting digits as u go
+        *--p = digit[i%10];
+        i = i/10;
+    }while(i);
+    return b;
+}
+
+//remove swap file of proc p;
+int
+removeSwapFile(struct proc* p)
+{
+	//path of proccess
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+	struct inode *ip, *dp;
+	struct dirent de;
+	char name[DIRSIZ];
+	uint off;
+
+	if(0 == p->swapFile)
+	{
+		return -1;
+	}
+	fileclose(p->swapFile);
+
+	begin_op();
+	if((dp = nameiparent(path, name)) == 0)
+	{
+		end_op();
+		return -1;
+	}
+
+	ilock(dp);
+
+	  // Cannot unlink "." or "..".
+	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+	   goto bad;
+
+	if((ip = dirlookup(dp, name, &off)) == 0)
+		goto bad;
+	ilock(ip);
+
+	if(ip->nlink < 1)
+		panic("unlink: nlink < 1");
+	if(ip->type == T_DIR && !isdirempty(ip)){
+		iunlockput(ip);
+		goto bad;
+	}
+
+	memset(&de, 0, sizeof(de));
+	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+		panic("unlink: writei");
+	if(ip->type == T_DIR){
+		dp->nlink--;
+		iupdate(dp);
+	}
+	iunlockput(dp);
+
+	ip->nlink--;
+	iupdate(ip);
+	iunlockput(ip);
+
+	end_op();
+
+	return 0;
+
+	bad:
+		iunlockput(dp);
+		end_op();
+		return -1;
+
+}
+
+
+//return 0 on success
+int
+createSwapFile(struct proc* p)
+{
+
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+    begin_op();
+    struct inode * in = create(path, T_FILE, 0, 0);
+	iunlock(in);
+
+	p->swapFile = filealloc();
+	if (p->swapFile == 0)
+		panic("no slot for files on /store");
+
+	p->swapFile->ip = in;
+	p->swapFile->type = FD_INODE;
+	p->swapFile->off = 0;
+	p->swapFile->readable = O_WRONLY;
+	p->swapFile->writable = O_RDWR;
+    end_op();
+
+    return 0;
+}
+
+//return as sys_write (-1 when error)
+int
+writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return filewrite(p->swapFile, buffer, size);
+
+}
+
+//return as sys_read (-1 when error)
+int
+readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return fileread(p->swapFile, buffer,  size);
+}
+
diff --git a/kalloc.c b/kalloc.c
index 14cd4f4..fd2b05c 100644
--- a/kalloc.c
+++ b/kalloc.c
@@ -9,6 +9,10 @@
 #include "mmu.h"
 #include "spinlock.h"
 
+#include "kalloc.h"
+
+struct physicalPageCountTracker physicalPageTracker;
+
 void freerange(void *vstart, void *vend);
 extern char end[]; // first address after kernel loaded from ELF file
                    // defined by the kernel linker script in kernel.ld
@@ -34,12 +38,19 @@ kinit1(void *vstart, void *vend)
   initlock(&kmem.lock, "kmem");
   kmem.use_lock = 0;
   freerange(vstart, vend);
+
+  physicalPageTracker.initPagesNo = (PGROUNDDOWN((uint)vend) - PGROUNDUP((uint)vstart)) / PGSIZE;
+  cprintf("physPagesCounts->initPagesNo = %d\n", physicalPageTracker.initPagesNo );
 }
 
 void
 kinit2(void *vstart, void *vend)
 {
   freerange(vstart, vend);
+
+  // update the # of pages inserted to free list in kinit2
+  physicalPageTracker.initPagesNo += (PGROUNDDOWN((uint)vend) - PGROUNDUP((uint)vstart)) / PGSIZE;
+
   kmem.use_lock = 1;
 }
 
@@ -72,6 +83,9 @@ kfree(char *v)
   r = (struct run*)v;
   r->next = kmem.freelist;
   kmem.freelist = r;
+
+  physicalPageTracker.currentFreePagesNo++;
+
   if(kmem.use_lock)
     release(&kmem.lock);
 }
@@ -87,8 +101,11 @@ kalloc(void)
   if(kmem.use_lock)
     acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r)
+  if(r){
     kmem.freelist = r->next;
+    physicalPageTracker.currentFreePagesNo--;
+  }
+
   if(kmem.use_lock)
     release(&kmem.lock);
   return (char*)r;
diff --git a/kalloc.h b/kalloc.h
new file mode 100644
index 0000000..e01b13a
--- /dev/null
+++ b/kalloc.h
@@ -0,0 +1,7 @@
+// struct for keeping track of the percent of free physical pages
+struct physicalPageCountTracker{
+    int initPagesNo;
+    int currentFreePagesNo;
+};
+
+extern struct physicalPageCountTracker physicalPageTracker;
\ No newline at end of file
diff --git a/memtest.c b/memtest.c
new file mode 100644
index 0000000..004b560
--- /dev/null
+++ b/memtest.c
@@ -0,0 +1,184 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "syscall.h"
+#include "selection.h"
+
+#define PGSIZE 4096
+#define DEBUG 0
+
+int
+main(int argc, char *argv[]) {
+
+#if FIFO
+
+    int i, j;
+    char *arr[14];
+    char input[10];
+    // Allocate all remaining 12 physical pages
+    for (i = 0; i < 12; ++i) {
+        arr[i] = sbrk(PGSIZE);
+        printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+    }
+    printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+    gets(input, 10);
+
+    /*
+    Allocate page 15.
+    This allocation would cause page 0 to move to the swap file, but upon returning
+    to user space, a PGFLT would occur and pages 0,1 will be hot-swapped.
+    Afterwards, page 1 is in the swap file, the rest are in memory.
+    */
+    arr[12] = sbrk(PGSIZE);
+    printf(1, "arr[12]=0x%x\n", arr[12]);
+    printf(1,
+           "Called sbrk(PGSIZE) for the 13th time, a page fault should occur and one page in swap file.\nPress any key...\n");
+    gets(input, 10);
+
+    /*
+    Allocate page 16.
+    This would cause page 2 to move to the swap file, but since it contains the
+    user stack, it would be hot-swapped with page 3.
+    Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+    */
+    arr[13] = sbrk(PGSIZE);
+    printf(1, "arr[13]=0x%x\n", arr[13]);
+    printf(1,
+           "Called sbrk(PGSIZE) for the 14th time, a page fault should occur and two pages in swap file.\nPress any key...\n");
+    gets(input, 10);
+
+    /*
+    Access page 3, causing a PGFLT, since it is in the swap file. It would be
+    hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+    and this process repeats a total of 5 times.
+    */
+    for (i = 0; i < 5; i++) {
+        for (j = 0; j < PGSIZE; j++)
+            arr[i][j] = 'k';
+    }
+    printf(1, "5 page faults should have occurred.\nPress any key...\n");
+    gets(input, 10);
+
+    if (fork() == 0) {
+        printf(1, "Child code running.\n");
+        printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+        gets(input, 10);
+
+        /*
+        The purpose of this write is to create a PGFLT in the child process, and
+        verify that it is caught and handled properly.
+        */
+        arr[5][0] = 't';
+        printf(1, "A page fault should have occurred for page 8.\nPress any key to exit the child code.\n");
+        gets(input, 10);
+
+        exit();
+    } else {
+        wait();
+
+        /*
+        Deallocate all the pages.
+        */
+        sbrk(-14 * PGSIZE);
+        printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+        gets(input, 10);
+    }
+
+#elif SCFIFO
+    int i, j;
+    char *arr[14];
+    char input[10];
+
+    // TODO delete
+    printf(1, "myMemTest: testing SCFIFO... \n");
+
+    // Allocate all remaining 12 physical pages
+    for (i = 0; i < 12; ++i) {
+        arr[i] = sbrk(PGSIZE);
+        printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+    }
+    printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+    gets(input, 10);
+
+    /*
+    Allocate page 15.
+    For this allocation, SCFIFO will consider moving page 0 to disk, but because it has been accessed, page 1 will be moved instead.
+    Afterwards, page 1 is in the swap file, the rest are in memory.
+    */
+    arr[12] = sbrk(PGSIZE);
+    printf(1, "arr[12]=0x%x\n", arr[12]);
+    printf(1, "Called sbrk(PGSIZE) for the 13th time, no page fault should occur and one page in swap file.\nPress any key...\n");
+    gets(input, 10);
+
+    /*
+    Allocate page 16.
+    For this allocation, SCFIFO will consider moving page 2 to disk, but because it has been accessed, page 3 will be moved instead.
+    Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+    */
+    arr[13] = sbrk(PGSIZE);
+    printf(1, "arr[13]=0x%x\n", arr[13]);
+    printf(1, "Called sbrk(PGSIZE) for the 14th time, no page fault should occur and two pages in swap file.\nPress any key...\n");
+    gets(input, 10);
+
+    /*
+    Access page 3, causing a PGFLT, since it is in the swap file. It would be
+    hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+    and this process repeats a total of 5 times.
+    */
+    for (i = 0; i < 5; i++) {
+        for (j = 0; j < PGSIZE; j++)
+            arr[i][j] = 'k';
+    }
+    printf(1, "5 page faults should have occurred.\nPress any key...\n");
+    gets(input, 10);
+
+    /*
+    If DEBUG flag is defined as != 0 this is just another example showing
+    that because SCFIFO doesn't page out accessed pages, no needless page faults occurr.
+    */
+    if(DEBUG){
+        for (i = 0; i < 5; i++) {
+            printf(1, "Writing to address 0x%x\n", arr[i]);
+            arr[i][0] = 'k';
+        }
+        //printf(1, "No page faults should have occurred.\nPress any key...\n");
+        gets(input, 10);
+    }
+
+    if (fork() == 0) {
+        printf(1, "Child code running.\n");
+        printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+        gets(input, 10);
+
+        /*
+        The purpose of this write is to create a PGFLT in the child process, and
+        verify that it is caught and handled properly.
+        */
+        arr[5][0] = 'k';
+        printf(1, "A Page fault should have occurred in child proccess.\nPress any key to exit the child code.\n");
+        gets(input, 10);
+
+        exit();
+    }
+    else {
+        wait();
+
+        /*
+        Deallocate all the pages.
+        */
+        sbrk(-14 * PGSIZE);
+        printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+        gets(input, 10);
+    }
+
+#else
+    char *arr[50];
+    int i = 50;
+    printf(1, "Commencing user test for default paging policy.\nNo page faults should occur.\n");
+    for (i = 0; i < 50; i++) {
+        arr[i] = sbrk(PGSIZE);
+        printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+    }
+#endif
+    exit();
+}
\ No newline at end of file
diff --git a/mmu.h b/mmu.h
index a82d8e2..f5a5bd1 100644
--- a/mmu.h
+++ b/mmu.h
@@ -19,7 +19,7 @@
 #define SEG_TSS   5  // this process's task state
 
 // cpu->gdt[NSEGS] holds the above segments.
-#define NSEGS     6
+#define NSEGS     7
 
 #ifndef __ASSEMBLER__
 // Segment Descriptor
@@ -95,10 +95,12 @@ struct segdesc {
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
 #define PTE_PS          0x080   // Page Size
+#define PTE_A           0x020   // Accessed
+#define PTE_PG          0x200   // Paged out to secondary storage
 
 // Address in page table or page directory entry
-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
+#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF) /// first 20 bits - ADDRESS
+#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF) /// last 12 bits - FLAGS
 
 #ifndef __ASSEMBLER__
 typedef uint pte_t;
diff --git a/paging.patch b/paging.patch
new file mode 100644
index 0000000..54ef2b9
--- /dev/null
+++ b/paging.patch
@@ -0,0 +1,225 @@
+diff --git a/defs.h b/defs.h
+index 82fb982..f33f2cb 100644
+--- a/defs.h
++++ b/defs.h
+@@ -52,6 +52,11 @@ struct inode*   nameiparent(char*, char*);
+ int             readi(struct inode*, char*, uint, uint);
+ void            stati(struct inode*, struct stat*);
+ int             writei(struct inode*, char*, uint, uint);
++int             createSwapFile(struct proc* p);
++int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
++int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
++int             removeSwapFile(struct proc* p);
++
+ 
+ // ide.c
+ void            ideinit(void);
+@@ -124,6 +129,11 @@ void            yield(void);
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+ 
++// sysfile
++struct inode*   create(char *path, short type, short major, short minor);
++int             isdirempty(struct inode *dp);
++
++
+ // spinlock.c
+ void            acquire(struct spinlock*);
+ void            getcallerpcs(void*, uint*);
+diff --git a/fs.c b/fs.c
+index feb59fe..f7c92cf 100644
+--- a/fs.c
++++ b/fs.c
+@@ -669,3 +669,144 @@ nameiparent(char *path, char *name)
+ {
+   return namex(path, 1, name);
+ }
++
++// NEW FOR PAGING
++
++#include "fcntl.h"
++#define DIGITS 14
++
++char* itoa(int i, char b[]){
++    char const digit[] = "0123456789";
++    char* p = b;
++    if(i<0){
++        *p++ = '-';
++        i *= -1;
++    }
++    int shifter = i;
++    do{ //Move to where representation ends
++        ++p;
++        shifter = shifter/10;
++    }while(shifter);
++    *p = '\0';
++    do{ //Move back, inserting digits as u go
++        *--p = digit[i%10];
++        i = i/10;
++    }while(i);
++    return b;
++}
++
++//remove swap file of proc p;
++int
++removeSwapFile(struct proc* p)
++{
++	//path of proccess
++	char path[DIGITS];
++	memmove(path,"/.swap", 6);
++	itoa(p->pid, path+ 6);
++
++	struct inode *ip, *dp;
++	struct dirent de;
++	char name[DIRSIZ];
++	uint off;
++
++	if(0 == p->swapFile)
++	{
++		return -1;
++	}
++	fileclose(p->swapFile);
++
++	begin_op();
++	if((dp = nameiparent(path, name)) == 0)
++	{
++		end_op();
++		return -1;
++	}
++
++	ilock(dp);
++
++	  // Cannot unlink "." or "..".
++	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
++	   goto bad;
++
++	if((ip = dirlookup(dp, name, &off)) == 0)
++		goto bad;
++	ilock(ip);
++
++	if(ip->nlink < 1)
++		panic("unlink: nlink < 1");
++	if(ip->type == T_DIR && !isdirempty(ip)){
++		iunlockput(ip);
++		goto bad;
++	}
++
++	memset(&de, 0, sizeof(de));
++	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++		panic("unlink: writei");
++	if(ip->type == T_DIR){
++		dp->nlink--;
++		iupdate(dp);
++	}
++	iunlockput(dp);
++
++	ip->nlink--;
++	iupdate(ip);
++	iunlockput(ip);
++
++	end_op();
++
++	return 0;
++
++	bad:
++		iunlockput(dp);
++		end_op();
++		return -1;
++
++}
++
++
++//return 0 on success
++int
++createSwapFile(struct proc* p)
++{
++
++	char path[DIGITS];
++	memmove(path,"/.swap", 6);
++	itoa(p->pid, path+ 6);
++
++    begin_op();
++    struct inode * in = create(path, T_FILE, 0, 0);
++	iunlock(in);
++
++	p->swapFile = filealloc();
++	if (p->swapFile == 0)
++		panic("no slot for files on /store");
++
++	p->swapFile->ip = in;
++	p->swapFile->type = FD_INODE;
++	p->swapFile->off = 0;
++	p->swapFile->readable = O_WRONLY;
++	p->swapFile->writable = O_RDWR;
++    end_op();
++
++    return 0;
++}
++
++//return as sys_write (-1 when error)
++int
++writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
++{
++	p->swapFile->off = placeOnFile;
++
++	return filewrite(p->swapFile, buffer, size);
++
++}
++
++//return as sys_read (-1 when error)
++int
++readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
++{
++	p->swapFile->off = placeOnFile;
++
++	return fileread(p->swapFile, buffer,  size);
++}
++
+diff --git a/mmu.h b/mmu.h
+index a82d8e2..aec4420 100644
+--- a/mmu.h
++++ b/mmu.h
+@@ -95,6 +95,8 @@ struct segdesc {
+ #define PTE_W           0x002   // Writeable
+ #define PTE_U           0x004   // User
+ #define PTE_PS          0x080   // Page Size
++#define PTE_A           0x020   // Accessed
++#define PTE_PG          0x200   // Paged out to secondary storage
+ 
+ // Address in page table or page directory entry
+ #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
+diff --git a/proc.h b/proc.h
+index 1647114..9f65fae 100644
+--- a/proc.h
++++ b/proc.h
+@@ -49,6 +49,8 @@ struct proc {
+   struct file *ofile[NOFILE];  // Open files
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
++  //Swap file. must initiate with create swap file
++  struct file *swapFile;			//page file
+ };
+ 
+ // Process memory is laid out contiguously, low addresses first:
+diff --git a/sysfile.c b/sysfile.c
+index 87e508b..22d3588 100644
+--- a/sysfile.c
++++ b/sysfile.c
+@@ -165,7 +165,7 @@ bad:
+ }
+ 
+ // Is the directory dp empty except for "." and ".." ?
+-static int
++int
+ isdirempty(struct inode *dp)
+ {
+   int off;
+@@ -238,7 +238,7 @@ bad:
+   return -1;
+ }
+ 
+-static struct inode*
++struct inode*
+ create(char *path, short type, short major, short minor)
+ {
+   uint off;
diff --git a/pagingUser.c b/pagingUser.c
new file mode 100644
index 0000000..0999095
--- /dev/null
+++ b/pagingUser.c
@@ -0,0 +1,183 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "syscall.h"
+#include "selection.h"
+
+#define PGSIZE 4096
+#define DEBUG 0
+
+int
+main(int argc, char *argv[]){
+
+#if FIFO
+
+    int i, j;
+	char *arr[14];
+	char input[10];
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	This allocation would cause page 0 to move to the swap file, but upon returning
+	to user space, a PGFLT would occur and pages 0,1 will be hot-swapped.
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, a page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	This would cause page 2 to move to the swap file, but since it contains the
+	user stack, it would be hot-swapped with page 3.
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, a page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		for (j = 0; j < PGSIZE; j++)
+			arr[i][j] = 'k';
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 't';
+		printf(1, "A page fault should have occurred for page 8.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+#elif SCFIFO
+    int i, j;
+	char *arr[14];
+	char input[10];
+
+	// TODO delete
+	printf(1, "myMemTest: testing SCFIFO... \n");
+
+	// Allocate all remaining 12 physical pages
+	for (i = 0; i < 12; ++i) {
+		arr[i] = sbrk(PGSIZE);
+		printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+	}
+	printf(1, "Called sbrk(PGSIZE) 12 times - all physical pages taken.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 15.
+	For this allocation, SCFIFO will consider moving page 0 to disk, but because it has been accessed, page 1 will be moved instead.
+	Afterwards, page 1 is in the swap file, the rest are in memory.
+	*/
+	arr[12] = sbrk(PGSIZE);
+	printf(1, "arr[12]=0x%x\n", arr[12]);
+	printf(1, "Called sbrk(PGSIZE) for the 13th time, no page fault should occur and one page in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Allocate page 16.
+	For this allocation, SCFIFO will consider moving page 2 to disk, but because it has been accessed, page 3 will be moved instead.
+	Afterwards, pages 1 & 3 are in the swap file, the rest are in memory.
+	*/
+	arr[13] = sbrk(PGSIZE);
+	printf(1, "arr[13]=0x%x\n", arr[13]);
+	printf(1, "Called sbrk(PGSIZE) for the 14th time, no page fault should occur and two pages in swap file.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	Access page 3, causing a PGFLT, since it is in the swap file. It would be
+	hot-swapped with page 4. Page 4 is accessed next, so another PGFLT is invoked,
+	and this process repeats a total of 5 times.
+	*/
+	for (i = 0; i < 5; i++) {
+		for (j = 0; j < PGSIZE; j++)
+			arr[i][j] = 'k';
+	}
+	printf(1, "5 page faults should have occurred.\nPress any key...\n");
+	gets(input, 10);
+
+	/*
+	If DEBUG flag is defined as != 0 this is just another example showing 
+	that because SCFIFO doesn't page out accessed pages, no needless page faults occurr.
+	*/
+	if(DEBUG){
+		for (i = 0; i < 5; i++) {
+			printf(1, "Writing to address 0x%x\n", arr[i]);
+			arr[i][0] = 'k';
+		}
+		//printf(1, "No page faults should have occurred.\nPress any key...\n");
+		gets(input, 10);
+	}
+
+	if (fork() == 0) {
+		printf(1, "Child code running.\n");
+		printf(1, "View statistics for pid %d, then press any key...\n", getpid());
+		gets(input, 10);
+
+		/*
+		The purpose of this write is to create a PGFLT in the child process, and
+		verify that it is caught and handled properly.
+		*/
+		arr[5][0] = 'k';
+		printf(1, "A Page fault should have occurred in child proccess.\nPress any key to exit the child code.\n");
+		gets(input, 10);
+
+		exit();
+	}
+	else {
+		wait();
+
+		/*
+		Deallocate all the pages.
+		*/
+		sbrk(-14 * PGSIZE);
+		printf(1, "Deallocated all extra pages.\nPress any key to exit the father code.\n");
+		gets(input, 10);
+	}
+
+#else
+    char* arr[50];
+    int i = 50;
+    printf(1, "Commencing user test for default paging policy.\nNo page faults should occur.\n");
+    for (i = 0; i < 50; i++) {
+        arr[i] = sbrk(PGSIZE);
+        printf(1, "arr[%d]=0x%x\n", i, arr[i]);
+    }
+#endif
+    exit();
+}
\ No newline at end of file
diff --git a/proc.c b/proc.c
index 806b1b1..618453c 100644
--- a/proc.c
+++ b/proc.c
@@ -6,309 +6,465 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "kalloc.h"
+#include "selection.h"
+
+#define DEBUG 0
 
 struct {
-  struct spinlock lock;
-  struct proc proc[NPROC];
+    struct spinlock lock;
+    struct proc proc[NPROC];
 } ptable;
 
 static struct proc *initproc;
 
 int nextpid = 1;
+
 extern void forkret(void);
+
 extern void trapret(void);
 
 static void wakeup1(void *chan);
 
 void
-pinit(void)
-{
-  initlock(&ptable.lock, "ptable");
+pinit(void) {
+    initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
 int
 cpuid() {
-  return mycpu()-cpus;
+    return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
-mycpu(void)
-{
-  int apicid, i;
-  
-  if(readeflags()&FL_IF)
-    panic("mycpu called with interrupts enabled\n");
-  
-  apicid = lapicid();
-  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-  // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
-    if (cpus[i].apicid == apicid)
-      return &cpus[i];
-  }
-  panic("unknown apicid\n");
+struct cpu *
+mycpu(void) {
+    int apicid, i;
+
+    if (readeflags() & FL_IF)
+        panic("mycpu called with interrupts enabled\n");
+
+    apicid = lapicid();
+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+    // a reverse map, or reserve a register to store &cpus[i].
+    for (i = 0; i < ncpu; ++i) {
+        if (cpus[i].apicid == apicid)
+            return &cpus[i];
+    }
+    panic("unknown apicid\n");
 }
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
+struct proc *
 myproc(void) {
-  struct cpu *c;
-  struct proc *p;
-  pushcli();
-  c = mycpu();
-  p = c->proc;
-  popcli();
-  return p;
+    struct cpu *c;
+    struct proc *p;
+    pushcli();
+    c = mycpu();
+    p = c->proc;
+    popcli();
+    return p;
 }
 
+
+void
+initProcessPageData(struct proc *p){
+    // initialize process's page data
+    int i;
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        p->FREE_PAGES[i].va = (char *) 0xffffffff;
+        p->FREE_PAGES[i].next = 0;
+        p->FREE_PAGES[i].prev = 0;
+        p->SWAPPED_PAGES[i].swaploc = 0;
+        p->SWAPPED_PAGES[i].va = (char *) 0xffffffff;
+    }
+    p->NUM_PAGES_IN_MEMORY = 0;
+    p->NUM_PAGES_IN_SWAP_FILE = 0;
+    p->NUM_TOTAL_PAGE_FAULT = 0;
+    p->NUM_TOTAL_PAGED_OUT = 0;
+    p->head = 0;
+    p->tail = 0;
+}
+
+
 //PAGEBREAK: 32
 // Look in the process table for an UNUSED proc.
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
-static struct proc*
-allocproc(void)
-{
-  struct proc *p;
-  char *sp;
+static struct proc *
+allocproc(void) {
+    struct proc *p;
+    char *sp;
+
+    acquire(&ptable.lock);
 
-  acquire(&ptable.lock);
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        if (p->state == UNUSED)
+            goto found;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
-      goto found;
+    release(&ptable.lock);
+    return 0;
 
-  release(&ptable.lock);
-  return 0;
+    found:
+    p->state = EMBRYO;
+    p->pid = nextpid++;
 
-found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
+    release(&ptable.lock);
 
-  release(&ptable.lock);
+    // Allocate kernel stack.
+    if ((p->kstack = kalloc()) == 0) {
+        p->state = UNUSED;
+        return 0;
+    }
+    sp = p->kstack + KSTACKSIZE;
 
-  // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
-    p->state = UNUSED;
-    return 0;
-  }
-  sp = p->kstack + KSTACKSIZE;
+    // Leave room for trap frame.
+    sp -= sizeof *p->tf;
+    p->tf = (struct trapframe *) sp;
+
+    // Set up new context to start executing at forkret,
+    // which returns to trapret.
+    sp -= 4;
+    *(uint *) sp = (uint) trapret;
 
-  // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+    sp -= sizeof *p->context;
+    p->context = (struct context *) sp;
+    memset(p->context, 0, sizeof *p->context);
+    p->context->eip = (uint) forkret;
 
-  // Set up new context to start executing at forkret,
-  // which returns to trapret.
-  sp -= 4;
-  *(uint*)sp = (uint)trapret;
 
-  sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
-  memset(p->context, 0, sizeof *p->context);
-  p->context->eip = (uint)forkret;
+    initProcessPageData(p);
 
-  return p;
+    return p;
 }
 
 //PAGEBREAK: 32
 // Set up first user process.
 void
-userinit(void)
-{
-  struct proc *p;
-  extern char _binary_initcode_start[], _binary_initcode_size[];
-
-  p = allocproc();
-  
-  initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
-    panic("userinit: out of memory?");
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
-  p->sz = PGSIZE;
-  memset(p->tf, 0, sizeof(*p->tf));
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-  p->tf->es = p->tf->ds;
-  p->tf->ss = p->tf->ds;
-  p->tf->eflags = FL_IF;
-  p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
-
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-  p->cwd = namei("/");
-
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
-
-  p->state = RUNNABLE;
-
-  release(&ptable.lock);
+userinit(void) {
+    struct proc *p;
+    extern char _binary_initcode_start[], _binary_initcode_size[];
+
+    p = allocproc();
+
+    initproc = p;
+    if ((p->pgdir = setupkvm()) == 0)
+        panic("userinit: out of memory?");
+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+    p->sz = PGSIZE;
+    memset(p->tf, 0, sizeof(*p->tf));
+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+    p->tf->es = p->tf->ds;
+    p->tf->ss = p->tf->ds;
+    p->tf->eflags = FL_IF;
+    p->tf->esp = PGSIZE;
+    p->tf->eip = 0;  // beginning of initcode.S
+
+    safestrcpy(p->name, "initcode", sizeof(p->name));
+    p->cwd = namei("/");
+
+    // this assignment to p->state lets other cores
+    // run this process. the acquire forces the above
+    // writes to be visible, and the lock is also needed
+    // because the assignment might not be atomic.
+    acquire(&ptable.lock);
+
+    p->state = RUNNABLE;
+
+    release(&ptable.lock);
 }
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
 int
-growproc(int n)
-{
-  uint sz;
-  struct proc *curproc = myproc();
-
-  sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  }
-  curproc->sz = sz;
-  switchuvm(curproc);
-  return 0;
+growproc(int n) {
+    uint sz;
+    struct proc *curproc = myproc();
+
+    sz = curproc->sz;
+    if (n > 0) {
+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+            return -1;
+    } else if (n < 0) {
+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+            return -1;
+    }
+    curproc->sz = sz;
+    switchuvm(curproc);
+    return 0;
+}
+
+
+
+void
+initializeChildProcess(struct proc *curproc, struct proc *np){
+    int i , j ;
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        np->FREE_PAGES[i].va = curproc->FREE_PAGES[i].va;
+        np->SWAPPED_PAGES[i].va = curproc->SWAPPED_PAGES[i].va;
+        np->SWAPPED_PAGES[i].swaploc = curproc->SWAPPED_PAGES[i].swaploc;
+    }
+
+    for (i = 0; i < MAX_PSYC_PAGES; i++)
+        for (j = 0; j < MAX_PSYC_PAGES; ++j)
+            if (np->FREE_PAGES[j].va == curproc->FREE_PAGES[i].next->va)
+                np->FREE_PAGES[i].next = &np->FREE_PAGES[j];
+    if (np->FREE_PAGES[j].va == curproc->FREE_PAGES[i].prev->va)
+        np->FREE_PAGES[i].prev = &np->FREE_PAGES[j];
+
+}
+
+
+void
+headCopyForChildern(struct proc *curproc, struct proc *np){
+    int i;
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        if (curproc->head->va == np->FREE_PAGES[i].va) {
+            //TODO delete cprintf("\nfork: head copied!\n\n");
+            np->head = &np->FREE_PAGES[i];
+        }
+        if (curproc->tail->va == np->FREE_PAGES[i].va)
+            np->tail = &np->FREE_PAGES[i];
+    }
 }
 
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
 int
-fork(void)
-{
-  int i, pid;
-  struct proc *np;
-  struct proc *curproc = myproc();
-
-  // Allocate process.
-  if((np = allocproc()) == 0){
-    return -1;
-  }
+fork(void) {
+    int i, j, pid;
+    struct proc *np;
+    struct proc *curproc = myproc();
+
+    // Allocate process.
+    if ((np = allocproc()) == 0) {
+        return -1;
+    }
 
-  // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
-    kfree(np->kstack);
-    np->kstack = 0;
-    np->state = UNUSED;
-    return -1;
-  }
-  np->sz = curproc->sz;
-  np->parent = curproc;
-  *np->tf = *curproc->tf;
+    // Copy process state from proc.
+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+        kfree(np->kstack);
+        np->kstack = 0;
+        np->state = UNUSED;
+        return -1;
+    }
 
-  // Clear %eax so that fork returns 0 in the child.
-  np->tf->eax = 0;
+    np->NUM_PAGES_IN_MEMORY = curproc->NUM_PAGES_IN_MEMORY;
+    np->NUM_PAGES_IN_SWAP_FILE = curproc->NUM_PAGES_IN_SWAP_FILE;
+
+    np->sz = curproc->sz;
+    np->parent = curproc;
+    *np->tf = *curproc->tf;
+
+    // Clear %eax so that fork returns 0 in the child.
+    np->tf->eax = 0;
+
+    for (i = 0; i < NOFILE; i++)
+        if (curproc->ofile[i])
+            np->ofile[i] = filedup(curproc->ofile[i]);
+    np->cwd = idup(curproc->cwd);
+
+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+
+    pid = np->pid;
+
+    ///////////////////////////////////////////////////////////////////////////
+    createSwapFile(np);
+
+    char buf[PGSIZE / 2] = "";
+    int offset = 0;
+    int nread = 0;
+    // read the parent's swap file in chunks of size PGDIR/2, otherwise for some
+    // reason, you get "panic acquire" if buf is ~4000 bytes
+    if (strncmp(curproc->name, "init", 4) != 0 && strncmp(curproc->name, "sh", 2) != 0) {
+//        cprintf("xyzzz\n");
+        while ((nread = readFromSwapFile(curproc, buf, offset, PGSIZE / 2)) != 0) {
+            if (writeToSwapFile(np, buf, offset, nread) == -1) {
+                panic("fork: error while writing the parent's swap file to the child");
+            }
+            offset += nread;
+        }
+    }
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
-      np->ofile[i] = filedup(curproc->ofile[i]);
-  np->cwd = idup(curproc->cwd);
+    initializeChildProcess(curproc, np);
 
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
-  pid = np->pid;
+#if FIFO
+    headCopyForChildern(curproc,np);
+#endif
 
-  acquire(&ptable.lock);
+#if SCFIFO
+    headCopyForChildern(curproc,np);
+#endif
 
-  np->state = RUNNABLE;
+    acquire(&ptable.lock);
+    np->state = RUNNABLE;
 
-  release(&ptable.lock);
+    release(&ptable.lock);
 
-  return pid;
+    return pid;
 }
 
+
+void
+printProcMemPageInfo(struct proc *curproc) {
+    static char *states[] = {
+            [UNUSED]    "unused",
+            [EMBRYO]    "embryo",
+            [SLEEPING]  "sleeping",
+            [RUNNABLE]  "runnable",
+            [RUNNING]   "running",
+            [ZOMBIE]    "zombie"
+    };
+    int i;
+    char *state;
+    uint pc[10];
+    struct freePage *l;
+
+    if (curproc->state >= 0 && curproc->state < NUMBERofELEMENT(states) && states[curproc->state])
+        state = states[curproc->state];
+    else
+        state = "???";
+
+    // regular xv6 procdump printing
+    cprintf("\npid:%d state:%s name:%s\n", curproc->pid, state, curproc->name);
+
+    //print out memory pages info:
+    cprintf("No. of pages currently in physical memory: %d,\n", curproc->NUM_PAGES_IN_MEMORY);
+    cprintf("No. of pages currently paged out: %d,\n", curproc->NUM_PAGES_IN_SWAP_FILE);
+    cprintf("Total No. of page faults: %d,\n", curproc->NUM_TOTAL_PAGE_FAULT);
+    cprintf("Total number of paged out pages: %d,\n\n", curproc->NUM_TOTAL_PAGED_OUT);
+
+    // regular xv6 procdump printing
+    if (curproc->state == SLEEPING) {
+        getcallerpcs((uint *) curproc->context->ebp + 2, pc);
+        for (i = 0; i < 10 && pc[i] != 0; i++)
+            cprintf(" %p", pc[i]);
+    }
+    if (DEBUG) {
+        for (i = 0; i < MAX_PSYC_PAGES; ++i) {
+            if (curproc->FREE_PAGES[i].va != (char *) 0xffffffff)
+                cprintf("freepages[%d].va = 0x%x \n", i, curproc->FREE_PAGES[i].va);
+        }
+        i = 0;
+        l = curproc->head;
+        if (l == 0)
+            cprintf("curproc->head == 0");
+        else {
+            cprintf("curproc->head == 0x%x , i=%d\n", l->va, ++i);
+            while (l->next != 0) {
+                l = l->next;
+                cprintf("next->va == 0x%x , i=%d\n", l->va, ++i);
+            }
+            cprintf("next link is null, list is finished!\n");
+        }
+        if (curproc->tail != 0)
+            cprintf("tail->va == 0x%x \n", curproc->tail->va);
+    }
+}
+
+
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
-exit(void)
-{
-  struct proc *curproc = myproc();
-  struct proc *p;
-  int fd;
-
-  if(curproc == initproc)
-    panic("init exiting");
-
-  // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
-      fileclose(curproc->ofile[fd]);
-      curproc->ofile[fd] = 0;
+exit(void) {
+    struct proc *curproc = myproc();
+    struct proc *p;
+    int fd;
+
+    if (curproc == initproc)
+        panic("init exiting");
+
+    // Close all open files.
+    for (fd = 0; fd < NOFILE; fd++) {
+        if (curproc->ofile[fd]) {
+            fileclose(curproc->ofile[fd]);
+            curproc->ofile[fd] = 0;
+        }
     }
-  }
 
-  begin_op();
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = 0;
+    if (removeSwapFile(curproc) != 0)
+        panic("exit: error deleting swap file");
+
+#if TRUE
+    // sending proc as arg just to share func with procdump
+  printProcMemPageInfo(curproc);
+#endif
+
 
-  acquire(&ptable.lock);
+    begin_op();
+    iput(curproc->cwd);
+    end_op();
+    curproc->cwd = 0;
 
-  // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
+    acquire(&ptable.lock);
+
+    // Parent might be sleeping in wait().
+    wakeup1(curproc->parent);
 
-  // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
-      p->parent = initproc;
-      if(p->state == ZOMBIE)
-        wakeup1(initproc);
+    // Pass abandoned children to init.
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if (p->parent == curproc) {
+            p->parent = initproc;
+            if (p->state == ZOMBIE)
+                wakeup1(initproc);
+        }
     }
-  }
 
-  // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
-  sched();
-  panic("zombie exit");
+    // Jump into the scheduler, never to return.
+    curproc->state = ZOMBIE;
+    sched();
+    panic("zombie exit");
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
-wait(void)
-{
-  struct proc *p;
-  int havekids, pid;
-  struct proc *curproc = myproc();
-  
-  acquire(&ptable.lock);
-  for(;;){
-    // Scan through table looking for exited children.
-    havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
-        continue;
-      havekids = 1;
-      if(p->state == ZOMBIE){
-        // Found one.
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
-        p->state = UNUSED;
-        release(&ptable.lock);
-        return pid;
-      }
-    }
+wait(void) {
+    struct proc *p;
+    int havekids, pid;
+    struct proc *curproc = myproc();
 
-    // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
-      release(&ptable.lock);
-      return -1;
+    acquire(&ptable.lock);
+    for (;;) {
+        // Scan through table looking for exited children.
+        havekids = 0;
+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+            if (p->parent != curproc)
+                continue;
+            havekids = 1;
+            if (p->state == ZOMBIE) {
+                // Found one.
+                pid = p->pid;
+                kfree(p->kstack);
+                p->kstack = 0;
+                freevm(p->pgdir);
+                p->pid = 0;
+                p->parent = 0;
+                p->name[0] = 0;
+                p->killed = 0;
+                p->state = UNUSED;
+                release(&ptable.lock);
+                return pid;
+            }
+        }
+
+        // No point waiting if we don't have any children.
+        if (!havekids || curproc->killed) {
+            release(&ptable.lock);
+            return -1;
+        }
+
+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+        sleep(curproc, &ptable.lock);  //DOC: wait-sleep
     }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-  }
 }
 
 //PAGEBREAK: 42
@@ -320,180 +476,172 @@ wait(void)
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
 void
-scheduler(void)
-{
-  struct proc *p;
-  struct cpu *c = mycpu();
-  c->proc = 0;
-  
-  for(;;){
-    // Enable interrupts on this processor.
-    sti();
-
-    // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      c->proc = 0;
-    }
-    release(&ptable.lock);
+scheduler(void) {
+    struct proc *p;
+    struct cpu *c = mycpu();
+    c->proc = 0;
+
+    for (;;) {
+        // Enable interrupts on this processor.
+        sti();
+
+        // Loop over process table looking for process to run.
+        acquire(&ptable.lock);
+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+            if (p->state != RUNNABLE)
+                continue;
+
+            // Switch to chosen process.  It is the process's job
+            // to release ptable.lock and then reacquire it
+            // before jumping back to us.
+            c->proc = p;
+            switchuvm(p);
+            p->state = RUNNING;
+
+            swtch(&(c->scheduler), p->context);
+            switchkvm();
+
+            // Process is done running for now.
+            // It should have changed its p->state before coming back.
+            c->proc = 0;
+        }
+        release(&ptable.lock);
 
-  }
+    }
 }
 
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
 // kernel thread, not this CPU. It should
-// be proc->intena and proc->ncli, but that would
+// be proc->intena and curproc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
 void
-sched(void)
-{
-  int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
-    panic("sched locks");
-  if(p->state == RUNNING)
-    panic("sched running");
-  if(readeflags()&FL_IF)
-    panic("sched interruptible");
-  intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
-  mycpu()->intena = intena;
+sched(void) {
+    int intena;
+    struct proc *p = myproc();
+
+    if (!holding(&ptable.lock))
+        panic("sched ptable.lock");
+    if (mycpu()->ncli != 1)
+        panic("sched locks");
+    if (p->state == RUNNING)
+        panic("sched running");
+    if (readeflags() & FL_IF)
+        panic("sched interruptible");
+    intena = mycpu()->intena;
+    swtch(&p->context, mycpu()->scheduler);
+    mycpu()->intena = intena;
 }
 
 // Give up the CPU for one scheduling round.
 void
-yield(void)
-{
-  acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
-  sched();
-  release(&ptable.lock);
+yield(void) {
+    acquire(&ptable.lock);  //DOC: yieldlock
+    myproc()->state = RUNNABLE;
+    sched();
+    release(&ptable.lock);
 }
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
 void
-forkret(void)
-{
-  static int first = 1;
-  // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-
-  if (first) {
-    // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot
-    // be run from main().
-    first = 0;
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
-  }
-
-  // Return to "caller", actually trapret (see allocproc).
+forkret(void) {
+    static int first = 1;
+    // Still holding ptable.lock from scheduler.
+    release(&ptable.lock);
+
+    if (first) {
+        // Some initialization functions must be run in the context
+        // of a regular process (e.g., they call sleep), and thus cannot
+        // be run from main().
+        first = 0;
+        iinit(ROOTDEV);
+        initlog(ROOTDEV);
+    }
+
+    // Return to "caller", actually trapret (see allocproc).
 }
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
 void
-sleep(void *chan, struct spinlock *lk)
-{
-  struct proc *p = myproc();
-  
-  if(p == 0)
-    panic("sleep");
-
-  if(lk == 0)
-    panic("sleep without lk");
-
-  // Must acquire ptable.lock in order to
-  // change p->state and then call sched.
-  // Once we hold ptable.lock, we can be
-  // guaranteed that we won't miss any wakeup
-  // (wakeup runs with ptable.lock locked),
-  // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
-    release(lk);
-  }
-  // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
-
-  sched();
-
-  // Tidy up.
-  p->chan = 0;
-
-  // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
-    release(&ptable.lock);
-    acquire(lk);
-  }
+sleep(void *chan, struct spinlock *lk) {
+    struct proc *p = myproc();
+
+    if (p == 0)
+        panic("sleep");
+
+    if (lk == 0)
+        panic("sleep without lk");
+
+    // Must acquire ptable.lock in order to
+    // change p->state and then call sched.
+    // Once we hold ptable.lock, we can be
+    // guaranteed that we won't miss any wakeup
+    // (wakeup runs with ptable.lock locked),
+    // so it's okay to release lk.
+    if (lk != &ptable.lock) {  //DOC: sleeplock0
+        acquire(&ptable.lock);  //DOC: sleeplock1
+        release(lk);
+    }
+    // Go to sleep.
+    p->chan = chan;
+    p->state = SLEEPING;
+
+    sched();
+
+    // Tidy up.
+    p->chan = 0;
+
+    // Reacquire original lock.
+    if (lk != &ptable.lock) {  //DOC: sleeplock2
+        release(&ptable.lock);
+        acquire(lk);
+    }
 }
 
 //PAGEBREAK!
 // Wake up all processes sleeping on chan.
 // The ptable lock must be held.
 static void
-wakeup1(void *chan)
-{
-  struct proc *p;
+wakeup1(void *chan) {
+    struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        if (p->state == SLEEPING && p->chan == chan)
+            p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
 void
-wakeup(void *chan)
-{
-  acquire(&ptable.lock);
-  wakeup1(chan);
-  release(&ptable.lock);
+wakeup(void *chan) {
+    acquire(&ptable.lock);
+    wakeup1(chan);
+    release(&ptable.lock);
 }
 
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
 int
-kill(int pid)
-{
-  struct proc *p;
-
-  acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
-      p->killed = 1;
-      // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
-      return 0;
+kill(int pid) {
+    struct proc *p;
+
+    acquire(&ptable.lock);
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if (p->pid == pid) {
+            p->killed = 1;
+            // Wake process from sleep if necessary.
+            if (p->state == SLEEPING)
+                p->state = RUNNABLE;
+            release(&ptable.lock);
+            return 0;
+        }
     }
-  }
-  release(&ptable.lock);
-  return -1;
+    release(&ptable.lock);
+    return -1;
 }
 
 //PAGEBREAK: 36
@@ -501,34 +649,31 @@ kill(int pid)
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
 void
-procdump(void)
-{
-  static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
-  int i;
-  struct proc *p;
-  char *state;
-  uint pc[10];
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
-      continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
+procdump(void) {
+    static char *states[] = {
+            [UNUSED]    "unused",
+            [EMBRYO]    "embryo",
+            [SLEEPING]  "sleep ",
+            [RUNNABLE]  "runble",
+            [RUNNING]   "run   ",
+            [ZOMBIE]    "zombie"
+    };
+    int i;
+
+    int percent;
+
+    struct proc *p;
+    char *state;
+    uint pc[10];
+
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if (p->state == UNUSED)
+            continue;
+
+        printProcMemPageInfo(p);
     }
-    cprintf("\n");
-  }
+
+    percent = physicalPageTracker.currentFreePagesNo * 100 / physicalPageTracker.initPagesNo;
+    cprintf("\n\nPercent of free physical pages: %d/%d ~ 0.%d%% \n", physicalPageTracker.currentFreePagesNo,
+            physicalPageTracker.initPagesNo, percent);
 }
diff --git a/proc.h b/proc.h
index 1647114..8f90ec8 100644
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,8 @@
+// Segments in proc->gdt.
+
+#define MAX_PSYC_PAGES 15
+#define MAX_TOTAL_PAGES 30
+
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -8,11 +13,27 @@ struct cpu {
   int ncli;                    // Depth of pushcli nesting.
   int intena;                  // Were interrupts enabled before pushcli?
   struct proc *proc;           // The process running on this cpu or null
+
+  // Cpu-local storage variables; see below
+  struct cpu *cpu;
 };
 
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
+
+// Per-CPU variables, holding pointers to the
+// current cpu and to the current process.
+// The asm suffix tells gcc to use "%gs:0" to refer to cpu
+// and "%gs:4" to refer to proc.  seginit sets up the
+// %gs segment register so that %gs refers to the memory
+// holding those two variables in the local cpu's struct cpu.
+// This is similar to how thread-local variables are implemented
+// in thread libraries such as Linux pthreads.
+extern struct cpu *cpu asm("%gs:0");       // &cpus[cpunum()]
+extern struct proc *proc asm("%gs:4");     // cpus[cpunum()].proc
+
+
 //PAGEBREAK: 17
 // Saved registers for kernel context switches.
 // Don't need to save all the segment registers (%cs, etc),
@@ -34,6 +55,17 @@ struct context {
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+struct pageInfo {
+    uint swaploc;
+    char *va;
+};
+
+struct freePage {
+    char *va;
+    struct freePage *next;
+    struct freePage *prev;
+};
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -49,6 +81,18 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  //Swap file. must initiate with create swap file
+  struct file *swapFile;			//page file
+
+    //int NUM_PAGES_IN_MEMORY, NUM_PAGES_IN_SWAP_FILE, NUM_TOTAL_PAGE_FAULT, NUM_TOTAL_PAGED_OUT;
+  int NUM_PAGES_IN_MEMORY;             // No. of pages in physical memory
+  int NUM_PAGES_IN_SWAP_FILE;        // No. of pages in swap file
+  int NUM_TOTAL_PAGE_FAULT;    // Total number of page faults for this process
+  int NUM_TOTAL_PAGED_OUT;     // Total number of pages that were placed in the swap file
+  struct freePage FREE_PAGES[MAX_PSYC_PAGES];  // Pre-allocated space for the pages in physical memory linked list
+  struct pageInfo SWAPPED_PAGES[MAX_PSYC_PAGES];// Pre-allocated space for the pages in swap file array
+  struct freePage *head;        // Head of the pages in physical memory linked list
+  struct freePage *tail;        // End of the pages in physical memory linked list
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/sc.sh b/sc.sh
new file mode 100755
index 0000000..ea738cc
--- /dev/null
+++ b/sc.sh
@@ -0,0 +1,3 @@
+make clean
+make
+make qemu
\ No newline at end of file
diff --git a/selection.h b/selection.h
new file mode 100644
index 0000000..e7ed5eb
--- /dev/null
+++ b/selection.h
@@ -0,0 +1,6 @@
+//
+// Created by shamiul93 on 2/9/19.
+//
+
+#define FIFO 1
+//#define SCFIFO 2
\ No newline at end of file
diff --git a/sh.c b/sh.c
index 054bab9..eab2096 100644
--- a/sh.c
+++ b/sh.c
@@ -14,247 +14,251 @@
 #define MAXARGS 10
 
 struct cmd {
-  int type;
+    int type;
 };
 
 struct execcmd {
-  int type;
-  char *argv[MAXARGS];
-  char *eargv[MAXARGS];
+    int type;
+    char *argv[MAXARGS];
+    char *eargv[MAXARGS];
 };
 
 struct redircmd {
-  int type;
-  struct cmd *cmd;
-  char *file;
-  char *efile;
-  int mode;
-  int fd;
+    int type;
+    struct cmd *cmd;
+    char *file;
+    char *efile;
+    int mode;
+    int fd;
 };
 
 struct pipecmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
+    int type;
+    struct cmd *left;
+    struct cmd *right;
 };
 
 struct listcmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
+    int type;
+    struct cmd *left;
+    struct cmd *right;
 };
 
 struct backcmd {
-  int type;
-  struct cmd *cmd;
+    int type;
+    struct cmd *cmd;
 };
 
 int fork1(void);  // Fork but panics on failure.
-void panic(char*);
-struct cmd *parsecmd(char*);
+void panic(char *);
+struct cmd *parsecmd(char *);
 
 // Execute cmd.  Never returns.
 void
-runcmd(struct cmd *cmd)
-{
-  int p[2];
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    exit();
-
-  switch(cmd->type){
-  default:
-    panic("runcmd");
-
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    if(ecmd->argv[0] == 0)
-      exit();
-    exec(ecmd->argv[0], ecmd->argv);
-    printf(2, "exec %s failed\n", ecmd->argv[0]);
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    close(rcmd->fd);
-    if(open(rcmd->file, rcmd->mode) < 0){
-      printf(2, "open %s failed\n", rcmd->file);
-      exit();
-    }
-    runcmd(rcmd->cmd);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(lcmd->left);
-    wait();
-    runcmd(lcmd->right);
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    if(pipe(p) < 0)
-      panic("pipe");
-    if(fork1() == 0){
-      close(1);
-      dup(p[1]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->left);
+runcmd(struct cmd *cmd) {
+    int p[2];
+    struct backcmd *bcmd;
+    struct execcmd *ecmd;
+    struct listcmd *lcmd;
+    struct pipecmd *pcmd;
+    struct redircmd *rcmd;
+
+    if (cmd == 0)
+        exit();
+
+    switch (cmd->type) {
+        default:
+            panic("runcmd");
+
+        case EXEC:
+            ecmd = (struct execcmd *) cmd;
+            if (ecmd->argv[0] == 0)
+                exit();
+            exec(ecmd->argv[0], ecmd->argv);
+            printf(2, "exec %s failed\n", ecmd->argv[0]);
+            break;
+
+        case REDIR:
+            rcmd = (struct redircmd *) cmd;
+            close(rcmd->fd);
+            if (open(rcmd->file, rcmd->mode) < 0) {
+                printf(2, "open %s failed\n", rcmd->file);
+                exit();
+            }
+            runcmd(rcmd->cmd);
+            break;
+
+        case LIST:
+            lcmd = (struct listcmd *) cmd;
+            if (fork1() == 0)
+                runcmd(lcmd->left);
+            wait();
+            runcmd(lcmd->right);
+            break;
+
+        case PIPE:
+            pcmd = (struct pipecmd *) cmd;
+            if (pipe(p) < 0)
+                panic("pipe");
+            if (fork1() == 0) {
+                close(1);
+                dup(p[1]);
+                close(p[0]);
+                close(p[1]);
+                runcmd(pcmd->left);
+            }
+            if (fork1() == 0) {
+                close(0);
+                dup(p[0]);
+                close(p[0]);
+                close(p[1]);
+                runcmd(pcmd->right);
+            }
+            close(p[0]);
+            close(p[1]);
+            wait();
+            wait();
+            break;
+
+        case BACK:
+            bcmd = (struct backcmd *) cmd;
+            if (fork1() == 0)
+                runcmd(bcmd->cmd);
+            break;
     }
-    if(fork1() == 0){
-      close(0);
-      dup(p[0]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->right);
-    }
-    close(p[0]);
-    close(p[1]);
-    wait();
-    wait();
-    break;
-
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(bcmd->cmd);
-    break;
-  }
-  exit();
+    exit();
 }
 
 int
-getcmd(char *buf, int nbuf)
-{
-  printf(2, "$ ");
-  memset(buf, 0, nbuf);
-  gets(buf, nbuf);
-  if(buf[0] == 0) // EOF
-    return -1;
-  return 0;
+getcmd(char *buf, int nbuf) {
+    printf(2, "$ ");
+    memset(buf, 0, nbuf);
+    gets(buf, nbuf);
+    if (buf[0] == 0) // EOF
+        return -1;
+    return 0;
 }
 
 int
-main(void)
-{
-  static char buf[100];
-  int fd;
-
-  // Ensure that three file descriptors are open.
-  while((fd = open("console", O_RDWR)) >= 0){
-    if(fd >= 3){
-      close(fd);
-      break;
+main(void) {
+    static char buf[100];
+    int fd;
+
+    // Ensure that three file descriptors are open.
+    while ((fd = open("console", O_RDWR)) >= 0) {
+        if (fd >= 3) {
+            close(fd);
+            break;
+        }
     }
-  }
-
-  // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Chdir must be called by the parent, not the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
-      if(chdir(buf+3) < 0)
-        printf(2, "cannot cd %s\n", buf+3);
-      continue;
+
+
+#ifdef FIFO
+    printf(1, "Paging policy: FIFO\n");
+#endif
+
+#ifdef SCFIFO
+    printf(1, "Paging policy: SCFIFO\n");
+#endif
+
+#if TRUE
+    printf(1, "Verbose printing selected.\n");
+#endif
+
+
+    // Read and run input commands.
+    while (getcmd(buf, sizeof(buf)) >= 0) {
+        if (buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' ') {
+            // Chdir must be called by the parent, not the child.
+            buf[strlen(buf) - 1] = 0;  // chop \n
+            if (chdir(buf + 3) < 0)
+                printf(2, "cannot cd %s\n", buf + 3);
+            continue;
+        }
+        if (fork1() == 0)
+            runcmd(parsecmd(buf));
+        wait();
     }
-    if(fork1() == 0)
-      runcmd(parsecmd(buf));
-    wait();
-  }
-  exit();
+    exit();
 }
 
 void
-panic(char *s)
-{
-  printf(2, "%s\n", s);
-  exit();
+panic(char *s) {
+    printf(2, "%s\n", s);
+    exit();
 }
 
 int
-fork1(void)
-{
-  int pid;
-
-  pid = fork();
-  if(pid == -1)
-    panic("fork");
-  return pid;
+fork1(void) {
+    int pid;
+
+    pid = fork();
+    if (pid == -1)
+        panic("fork");
+    return pid;
 }
 
 //PAGEBREAK!
 // Constructors
 
-struct cmd*
-execcmd(void)
-{
-  struct execcmd *cmd;
+struct cmd *
+execcmd(void) {
+    struct execcmd *cmd;
 
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = EXEC;
-  return (struct cmd*)cmd;
+    cmd = malloc(sizeof(*cmd));
+    memset(cmd, 0, sizeof(*cmd));
+    cmd->type = EXEC;
+    return (struct cmd *) cmd;
 }
 
-struct cmd*
-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
-{
-  struct redircmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = REDIR;
-  cmd->cmd = subcmd;
-  cmd->file = file;
-  cmd->efile = efile;
-  cmd->mode = mode;
-  cmd->fd = fd;
-  return (struct cmd*)cmd;
+struct cmd *
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd) {
+    struct redircmd *cmd;
+
+    cmd = malloc(sizeof(*cmd));
+    memset(cmd, 0, sizeof(*cmd));
+    cmd->type = REDIR;
+    cmd->cmd = subcmd;
+    cmd->file = file;
+    cmd->efile = efile;
+    cmd->mode = mode;
+    cmd->fd = fd;
+    return (struct cmd *) cmd;
 }
 
-struct cmd*
-pipecmd(struct cmd *left, struct cmd *right)
-{
-  struct pipecmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = PIPE;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
+struct cmd *
+pipecmd(struct cmd *left, struct cmd *right) {
+    struct pipecmd *cmd;
+
+    cmd = malloc(sizeof(*cmd));
+    memset(cmd, 0, sizeof(*cmd));
+    cmd->type = PIPE;
+    cmd->left = left;
+    cmd->right = right;
+    return (struct cmd *) cmd;
 }
 
-struct cmd*
-listcmd(struct cmd *left, struct cmd *right)
-{
-  struct listcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = LIST;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
+struct cmd *
+listcmd(struct cmd *left, struct cmd *right) {
+    struct listcmd *cmd;
+
+    cmd = malloc(sizeof(*cmd));
+    memset(cmd, 0, sizeof(*cmd));
+    cmd->type = LIST;
+    cmd->left = left;
+    cmd->right = right;
+    return (struct cmd *) cmd;
 }
 
-struct cmd*
-backcmd(struct cmd *subcmd)
-{
-  struct backcmd *cmd;
+struct cmd *
+backcmd(struct cmd *subcmd) {
+    struct backcmd *cmd;
 
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = BACK;
-  cmd->cmd = subcmd;
-  return (struct cmd*)cmd;
+    cmd = malloc(sizeof(*cmd));
+    memset(cmd, 0, sizeof(*cmd));
+    cmd->type = BACK;
+    cmd->cmd = subcmd;
+    return (struct cmd *) cmd;
 }
 //PAGEBREAK!
 // Parsing
@@ -263,231 +267,225 @@ char whitespace[] = " \t\r\n\v";
 char symbols[] = "<|>&;()";
 
 int
-gettoken(char **ps, char *es, char **q, char **eq)
-{
-  char *s;
-  int ret;
-
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  if(q)
-    *q = s;
-  ret = *s;
-  switch(*s){
-  case 0:
-    break;
-  case '|':
-  case '(':
-  case ')':
-  case ';':
-  case '&':
-  case '<':
-    s++;
-    break;
-  case '>':
-    s++;
-    if(*s == '>'){
-      ret = '+';
-      s++;
+gettoken(char **ps, char *es, char **q, char **eq) {
+    char *s;
+    int ret;
+
+    s = *ps;
+    while (s < es && strchr(whitespace, *s))
+        s++;
+    if (q)
+        *q = s;
+    ret = *s;
+    switch (*s) {
+        case 0:
+            break;
+        case '|':
+        case '(':
+        case ')':
+        case ';':
+        case '&':
+        case '<':
+            s++;
+            break;
+        case '>':
+            s++;
+            if (*s == '>') {
+                ret = '+';
+                s++;
+            }
+            break;
+        default:
+            ret = 'a';
+            while (s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+                s++;
+            break;
     }
-    break;
-  default:
-    ret = 'a';
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-      s++;
-    break;
-  }
-  if(eq)
-    *eq = s;
-
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return ret;
+    if (eq)
+        *eq = s;
+
+    while (s < es && strchr(whitespace, *s))
+        s++;
+    *ps = s;
+    return ret;
 }
 
 int
-peek(char **ps, char *es, char *toks)
-{
-  char *s;
-
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return *s && strchr(toks, *s);
+peek(char **ps, char *es, char *toks) {
+    char *s;
+
+    s = *ps;
+    while (s < es && strchr(whitespace, *s))
+        s++;
+    *ps = s;
+    return *s && strchr(toks, *s);
 }
 
-struct cmd *parseline(char**, char*);
-struct cmd *parsepipe(char**, char*);
-struct cmd *parseexec(char**, char*);
-struct cmd *nulterminate(struct cmd*);
-
-struct cmd*
-parsecmd(char *s)
-{
-  char *es;
-  struct cmd *cmd;
-
-  es = s + strlen(s);
-  cmd = parseline(&s, es);
-  peek(&s, es, "");
-  if(s != es){
-    printf(2, "leftovers: %s\n", s);
-    panic("syntax");
-  }
-  nulterminate(cmd);
-  return cmd;
+struct cmd *parseline(char **, char *);
+
+struct cmd *parsepipe(char **, char *);
+
+struct cmd *parseexec(char **, char *);
+
+struct cmd *nulterminate(struct cmd *);
+
+struct cmd *
+parsecmd(char *s) {
+    char *es;
+    struct cmd *cmd;
+
+    es = s + strlen(s);
+    cmd = parseline(&s, es);
+    peek(&s, es, "");
+    if (s != es) {
+        printf(2, "leftovers: %s\n", s);
+        panic("syntax");
+    }
+    nulterminate(cmd);
+    return cmd;
 }
 
-struct cmd*
-parseline(char **ps, char *es)
-{
-  struct cmd *cmd;
+struct cmd *
+parseline(char **ps, char *es) {
+    struct cmd *cmd;
 
-  cmd = parsepipe(ps, es);
-  while(peek(ps, es, "&")){
-    gettoken(ps, es, 0, 0);
-    cmd = backcmd(cmd);
-  }
-  if(peek(ps, es, ";")){
-    gettoken(ps, es, 0, 0);
-    cmd = listcmd(cmd, parseline(ps, es));
-  }
-  return cmd;
+    cmd = parsepipe(ps, es);
+    while (peek(ps, es, "&")) {
+        gettoken(ps, es, 0, 0);
+        cmd = backcmd(cmd);
+    }
+    if (peek(ps, es, ";")) {
+        gettoken(ps, es, 0, 0);
+        cmd = listcmd(cmd, parseline(ps, es));
+    }
+    return cmd;
 }
 
-struct cmd*
-parsepipe(char **ps, char *es)
-{
-  struct cmd *cmd;
+struct cmd *
+parsepipe(char **ps, char *es) {
+    struct cmd *cmd;
 
-  cmd = parseexec(ps, es);
-  if(peek(ps, es, "|")){
-    gettoken(ps, es, 0, 0);
-    cmd = pipecmd(cmd, parsepipe(ps, es));
-  }
-  return cmd;
+    cmd = parseexec(ps, es);
+    if (peek(ps, es, "|")) {
+        gettoken(ps, es, 0, 0);
+        cmd = pipecmd(cmd, parsepipe(ps, es));
+    }
+    return cmd;
 }
 
-struct cmd*
-parseredirs(struct cmd *cmd, char **ps, char *es)
-{
-  int tok;
-  char *q, *eq;
-
-  while(peek(ps, es, "<>")){
-    tok = gettoken(ps, es, 0, 0);
-    if(gettoken(ps, es, &q, &eq) != 'a')
-      panic("missing file for redirection");
-    switch(tok){
-    case '<':
-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
-      break;
-    case '>':
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    case '+':  // >>
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
+struct cmd *
+parseredirs(struct cmd *cmd, char **ps, char *es) {
+    int tok;
+    char *q, *eq;
+
+    while (peek(ps, es, "<>")) {
+        tok = gettoken(ps, es, 0, 0);
+        if (gettoken(ps, es, &q, &eq) != 'a')
+            panic("missing file for redirection");
+        switch (tok) {
+            case '<':
+                cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+                break;
+            case '>':
+                cmd = redircmd(cmd, q, eq, O_WRONLY | O_CREATE, 1);
+                break;
+            case '+':  // >>
+                cmd = redircmd(cmd, q, eq, O_WRONLY | O_CREATE, 1);
+                break;
+        }
     }
-  }
-  return cmd;
+    return cmd;
 }
 
-struct cmd*
-parseblock(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  if(!peek(ps, es, "("))
-    panic("parseblock");
-  gettoken(ps, es, 0, 0);
-  cmd = parseline(ps, es);
-  if(!peek(ps, es, ")"))
-    panic("syntax - missing )");
-  gettoken(ps, es, 0, 0);
-  cmd = parseredirs(cmd, ps, es);
-  return cmd;
+struct cmd *
+parseblock(char **ps, char *es) {
+    struct cmd *cmd;
+
+    if (!peek(ps, es, "("))
+        panic("parseblock");
+    gettoken(ps, es, 0, 0);
+    cmd = parseline(ps, es);
+    if (!peek(ps, es, ")"))
+        panic("syntax - missing )");
+    gettoken(ps, es, 0, 0);
+    cmd = parseredirs(cmd, ps, es);
+    return cmd;
 }
 
-struct cmd*
-parseexec(char **ps, char *es)
-{
-  char *q, *eq;
-  int tok, argc;
-  struct execcmd *cmd;
-  struct cmd *ret;
-
-  if(peek(ps, es, "("))
-    return parseblock(ps, es);
-
-  ret = execcmd();
-  cmd = (struct execcmd*)ret;
-
-  argc = 0;
-  ret = parseredirs(ret, ps, es);
-  while(!peek(ps, es, "|)&;")){
-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
-      break;
-    if(tok != 'a')
-      panic("syntax");
-    cmd->argv[argc] = q;
-    cmd->eargv[argc] = eq;
-    argc++;
-    if(argc >= MAXARGS)
-      panic("too many args");
+struct cmd *
+parseexec(char **ps, char *es) {
+    char *q, *eq;
+    int tok, argc;
+    struct execcmd *cmd;
+    struct cmd *ret;
+
+    if (peek(ps, es, "("))
+        return parseblock(ps, es);
+
+    ret = execcmd();
+    cmd = (struct execcmd *) ret;
+
+    argc = 0;
     ret = parseredirs(ret, ps, es);
-  }
-  cmd->argv[argc] = 0;
-  cmd->eargv[argc] = 0;
-  return ret;
+    while (!peek(ps, es, "|)&;")) {
+        if ((tok = gettoken(ps, es, &q, &eq)) == 0)
+            break;
+        if (tok != 'a')
+            panic("syntax");
+        cmd->argv[argc] = q;
+        cmd->eargv[argc] = eq;
+        argc++;
+        if (argc >= MAXARGS)
+            panic("too many args");
+        ret = parseredirs(ret, ps, es);
+    }
+    cmd->argv[argc] = 0;
+    cmd->eargv[argc] = 0;
+    return ret;
 }
 
 // NUL-terminate all the counted strings.
-struct cmd*
-nulterminate(struct cmd *cmd)
-{
-  int i;
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    return 0;
-
-  switch(cmd->type){
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    for(i=0; ecmd->argv[i]; i++)
-      *ecmd->eargv[i] = 0;
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    nulterminate(rcmd->cmd);
-    *rcmd->efile = 0;
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    nulterminate(pcmd->left);
-    nulterminate(pcmd->right);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    nulterminate(lcmd->left);
-    nulterminate(lcmd->right);
-    break;
-
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    nulterminate(bcmd->cmd);
-    break;
-  }
-  return cmd;
+struct cmd *
+nulterminate(struct cmd *cmd) {
+    int i;
+    struct backcmd *bcmd;
+    struct execcmd *ecmd;
+    struct listcmd *lcmd;
+    struct pipecmd *pcmd;
+    struct redircmd *rcmd;
+
+    if (cmd == 0)
+        return 0;
+
+    switch (cmd->type) {
+        case EXEC:
+            ecmd = (struct execcmd *) cmd;
+            for (i = 0; ecmd->argv[i]; i++)
+                *ecmd->eargv[i] = 0;
+            break;
+
+        case REDIR:
+            rcmd = (struct redircmd *) cmd;
+            nulterminate(rcmd->cmd);
+            *rcmd->efile = 0;
+            break;
+
+        case PIPE:
+            pcmd = (struct pipecmd *) cmd;
+            nulterminate(pcmd->left);
+            nulterminate(pcmd->right);
+            break;
+
+        case LIST:
+            lcmd = (struct listcmd *) cmd;
+            nulterminate(lcmd->left);
+            nulterminate(lcmd->right);
+            break;
+
+        case BACK:
+            bcmd = (struct backcmd *) cmd;
+            nulterminate(bcmd->cmd);
+            break;
+    }
+    return cmd;
 }
diff --git a/syscall.c b/syscall.c
index ee85261..c2860a4 100644
--- a/syscall.c
+++ b/syscall.c
@@ -135,7 +135,7 @@ syscall(void)
   struct proc *curproc = myproc();
 
   num = curproc->tf->eax;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+  if(num > 0 && num < NUMBERofELEMENT(syscalls) && syscalls[num]) {
     curproc->tf->eax = syscalls[num]();
   } else {
     cprintf("%d %s: unknown sys call %d\n",
diff --git a/sysfile.c b/sysfile.c
index 87e508b..631be11 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -165,7 +165,7 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
+int
 isdirempty(struct inode *dp)
 {
   int off;
@@ -238,7 +238,7 @@ bad:
   return -1;
 }
 
-static struct inode*
+struct inode*
 create(char *path, short type, short major, short minor)
 {
   uint off;
@@ -406,7 +406,7 @@ sys_exec(void)
   }
   memset(argv, 0, sizeof(argv));
   for(i=0;; i++){
-    if(i >= NELEM(argv))
+    if(i >= NUMBERofELEMENT(argv))
       return -1;
     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
       return -1;
diff --git a/trap.c b/trap.c
index 41c66eb..53ee3f8 100644
--- a/trap.c
+++ b/trap.c
@@ -7,6 +7,7 @@
 #include "x86.h"
 #include "traps.h"
 #include "spinlock.h"
+#include "types.h"
 
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
@@ -15,98 +16,115 @@ struct spinlock tickslock;
 uint ticks;
 
 void
-tvinit(void)
-{
-  int i;
+tvinit(void) {
+    int i;
 
-  for(i = 0; i < 256; i++)
-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+    for (i = 0; i < 256; i++) SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
+    SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
 
-  initlock(&tickslock, "time");
+    initlock(&tickslock, "time");
 }
 
 void
-idtinit(void)
-{
-  lidt(idt, sizeof(idt));
+idtinit(void) {
+    lidt(idt, sizeof(idt));
 }
 
 //PAGEBREAK: 41
 void
-trap(struct trapframe *tf)
-{
-  if(tf->trapno == T_SYSCALL){
-    if(myproc()->killed)
-      exit();
-    myproc()->tf = tf;
-    syscall();
-    if(myproc()->killed)
-      exit();
-    return;
-  }
+trap(struct trapframe *tf) {
+
+    uint addr;
+    pde_t *vaddr;
+    struct proc *curproc = myproc();
 
-  switch(tf->trapno){
-  case T_IRQ0 + IRQ_TIMER:
-    if(cpuid() == 0){
-      acquire(&tickslock);
-      ticks++;
-      wakeup(&ticks);
-      release(&tickslock);
+    if (tf->trapno == T_SYSCALL) {
+        if (myproc()->killed)
+            exit();
+        myproc()->tf = tf;
+        syscall();
+        if (myproc()->killed)
+            exit();
+        return;
     }
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_IDE:
-    ideintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_IDE+1:
-    // Bochs generates spurious IDE1 interrupts.
-    break;
-  case T_IRQ0 + IRQ_KBD:
-    kbdintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_COM1:
-    uartintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + 7:
-  case T_IRQ0 + IRQ_SPURIOUS:
-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
-            cpuid(), tf->cs, tf->eip);
-    lapiceoi();
-    break;
 
-  //PAGEBREAK: 13
-  default:
-    if(myproc() == 0 || (tf->cs&3) == 0){
-      // In kernel, it must be our mistake.
-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-              tf->trapno, cpuid(), tf->eip, rcr2());
-      panic("trap");
+    switch (tf->trapno) {
+        case T_IRQ0 + IRQ_TIMER:
+            if (cpuid() == 0) {
+                acquire(&tickslock);
+                ticks++;
+                wakeup(&ticks);
+                release(&tickslock);
+            }
+            lapiceoi();
+            break;
+        case T_IRQ0 + IRQ_IDE:
+            ideintr();
+            lapiceoi();
+            break;
+        case T_IRQ0 + IRQ_IDE + 1:
+            // Bochs generates spurious IDE1 interrupts.
+            break;
+        case T_IRQ0 + IRQ_KBD:
+            kbdintr();
+            lapiceoi();
+            break;
+        case T_IRQ0 + IRQ_COM1:
+            uartintr();
+            lapiceoi();
+            break;
+        case T_IRQ0 + 7:
+        case T_IRQ0 + IRQ_SPURIOUS:
+            cprintf("cpu%d: spurious interrupt at %x:%x\n",
+                    cpuid(), tf->cs, tf->eip);
+            lapiceoi();
+            break;
+
+
+        case T_PGFLT:
+            addr = rcr2();
+            vaddr = &curproc->pgdir[PDX(addr)];
+            // cprintf("addr:0x%x vaddr:0x%x PDX:0x%x PTX:0x%x FLAGS:0x%x\n", addr, vaddr, PDX(*vaddr),PTX(*vaddr),PTE_FLAGS(*vaddr)); //TODO delete
+            // cprintf("&PTE_PG:%x &PTE_P:%x\n", (((uint*)PTE_ADDR(P2V(*vaddr)))[PTX(addr)] & PTE_PG), ((((uint*)PTE_ADDR(P2V(*vaddr)))[PTX(addr)] & PTE_P))); //TODO delete
+            if (((int) (*vaddr) & PTE_P) != 0) { // if page table isn't present at page directory -> hard page fault
+                if (((uint *) PTE_ADDR(P2V(*vaddr)))[PTX(addr)] & PTE_PG) { // if the page is in the process's swap file
+                    // cprintf("page is in swap file, pid %d, va %p\n", proc->pid, addr); //TODO delete
+                    pageSwap(PTE_ADDR(addr));
+                    ++curproc->NUM_TOTAL_PAGE_FAULT;
+                    // cprintf("proc->totalPageFaultCount:%d\n", ++proc->totalPageFaultCount);//TODO delete
+                    return;
+                }
+            }
+
+            //PAGEBREAK: 13
+        default:
+            if (myproc() == 0 || (tf->cs & 3) == 0) {
+                // In kernel, it must be our mistake.
+                cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+                        tf->trapno, cpuid(), tf->eip, rcr2());
+                panic("trap");
+            }
+            // In user space, assume process misbehaved.
+            cprintf("pid %d %s: trap %d err %d on cpu %d "
+                    "eip 0x%x addr 0x%x--kill proc\n",
+                    myproc()->pid, myproc()->name, tf->trapno,
+                    tf->err, cpuid(), tf->eip, rcr2());
+            myproc()->killed = 1;
     }
-    // In user space, assume process misbehaved.
-    cprintf("pid %d %s: trap %d err %d on cpu %d "
-            "eip 0x%x addr 0x%x--kill proc\n",
-            myproc()->pid, myproc()->name, tf->trapno,
-            tf->err, cpuid(), tf->eip, rcr2());
-    myproc()->killed = 1;
-  }
 
-  // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
-  // until it gets to the regular system call return.)
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    // Force process exit if it has been killed and is in user space.
+    // (If it is still executing in the kernel, let it keep running
+    // until it gets to the regular system call return.)
+    if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
+        exit();
 
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+    // Force process to give up CPU on clock tick.
+    // If interrupts were on while locks held, would need to check nlock.
+    if (myproc() && myproc()->state == RUNNING &&
+        tf->trapno == T_IRQ0 + IRQ_TIMER)
+        yield();
 
-  // Check if the process has been killed since we yielded
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    // Check if the process has been killed since we yielded
+    if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
+        exit();
 }
diff --git a/vm.c b/vm.c
index 7134cff..2eae24c 100644
--- a/vm.c
+++ b/vm.c
@@ -6,77 +6,103 @@
 #include "mmu.h"
 #include "proc.h"
 #include "elf.h"
+#include "selection.h"
+
+#define BUF_SIZE PGSIZE/4
+#define MAX_POSSIBLE ~0x80000000
+//using 0x80000000 introduces "negative" numbers which r a problem.
+#define DEBUG 0
+
 
 extern char data[];  // defined by kernel.ld
 pde_t *kpgdir;  // for use in scheduler()
+struct segdesc gdt[NSEGS];
+
+int deallocCount = 0;
 
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
 void
-seginit(void)
-{
-  struct cpu *c;
-
-  // Map "logical" addresses to virtual addresses using identity map.
-  // Cannot share a CODE descriptor for both kernel and user
-  // because it would have to have DPL_USR, but the CPU forbids
-  // an interrupt from CPL=0 to DPL=3.
-  c = &cpus[cpuid()];
-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
-  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
-  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
-  lgdt(c->gdt, sizeof(c->gdt));
+seginit(void) {
+    struct cpu *c;
+
+    // Map "logical" addresses to virtual addresses using identity map.
+    // Cannot share a CODE descriptor for both kernel and user
+    // because it would have to have DPL_USR, but the CPU forbids
+    // an interrupt from CPL=0 to DPL=3.
+    c = &cpus[cpuid()];
+    c->gdt[SEG_KCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, 0);
+    c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+    c->gdt[SEG_UCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, DPL_USER);
+    c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+    lgdt(c->gdt, sizeof(c->gdt));
 }
 
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
 static pte_t *
-walkpgdir(pde_t *pgdir, const void *va, int alloc)
-{
-  pde_t *pde;
-  pte_t *pgtab;
-
-  pde = &pgdir[PDX(va)];
-  if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
-  } else {
-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
-      return 0;
-    // Make sure all those PTE_P bits are zero.
-    memset(pgtab, 0, PGSIZE);
-    // The permissions here are overly generous, but they can
-    // be further restricted by the permissions in the page table
-    // entries, if necessary.
-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
-  }
-  return &pgtab[PTX(va)];
+walkpgdir(pde_t *pgdir, const void *va, int alloc) {
+    pde_t *pde;
+    pte_t *pgtab;
+
+    pde = &pgdir[PDX(va)];
+    if (*pde & PTE_P) {
+        pgtab = (pte_t *) P2V(PTE_ADDR(*pde));
+    } else {
+        if (!alloc || (pgtab = (pte_t *) kalloc()) == 0)
+            return 0;
+        // Make sure all those PTE_P bits are zero.
+        memset(pgtab, 0, PGSIZE);
+        // The permissions here are overly generous, but they can
+        // be further restricted by the permissions in the page table
+        // entries, if necessary.
+        *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    }
+    return &pgtab[PTX(va)];
 }
 
+void
+isProcessAccessed() {
+    int i;
+    pte_t *pte1;
+    struct proc *curproc = myproc();
+
+    //cprintf("checkAccessedBit\n");
+    for (i = 0; i < MAX_PSYC_PAGES; i++)
+        if (curproc->FREE_PAGES[i].va != (char *) 0xffffffff) {
+            pte1 = walkpgdir(curproc->pgdir, (void *) curproc->FREE_PAGES[i].va, 0);
+            if (!*pte1) {
+                cprintf("checkAccessedBit: pte1 is empty\n");
+                continue;
+            }
+            cprintf("checkAccessedBit: pte1 & PTE_A == %d\n", (*pte1) & PTE_A);
+        }
+}
+
+
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
 static int
-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
-{
-  char *a, *last;
-  pte_t *pte;
-
-  a = (char*)PGROUNDDOWN((uint)va);
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-  for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
-      return -1;
-    if(*pte & PTE_P)
-      panic("remap");
-    *pte = pa | perm | PTE_P;
-    if(a == last)
-      break;
-    a += PGSIZE;
-    pa += PGSIZE;
-  }
-  return 0;
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm) {
+    char *a, *last;
+    pte_t *pte;
+
+    a = (char *) PGROUNDDOWN((uint) va);
+    last = (char *) PGROUNDDOWN(((uint) va) + size - 1);
+    for (;;) {
+        if ((pte = walkpgdir(pgdir, a, 1)) == 0)
+            return -1;
+        if (*pte & PTE_P)
+            panic("remap");
+        *pte = pa | perm | PTE_P;
+        if (a == last)
+            break;
+        a += PGSIZE;
+        pa += PGSIZE;
+    }
+    return 0;
 }
 
 // There is one page table per process, plus one that's used when
@@ -103,149 +129,362 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 // This table defines the kernel's mappings, which are present in
 // every process's page table.
 static struct kmap {
-  void *virt;
-  uint phys_start;
-  uint phys_end;
-  int perm;
+    void *virt;
+    uint phys_start;
+    uint phys_end;
+    int perm;
 } kmap[] = {
- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+        {(void *) KERNBASE, 0,             EXTMEM,  PTE_W}, // I/O space
+        {(void *) KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
+        {(void *) data,     V2P(data),     PHYSTOP, PTE_W}, // kern data+memory
+        {(void *) DEVSPACE, DEVSPACE, 0,            PTE_W}, // more devices
 };
 
 // Set up kernel part of a page table.
-pde_t*
-setupkvm(void)
-{
-  pde_t *pgdir;
-  struct kmap *k;
-
-  if((pgdir = (pde_t*)kalloc()) == 0)
-    return 0;
-  memset(pgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
-    panic("PHYSTOP too high");
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
-      freevm(pgdir);
-      return 0;
+pde_t *
+setupkvm(void) {
+    pde_t *pgdir;
+    struct kmap *k;
+
+    if ((pgdir = (pde_t *) kalloc()) == 0)
+        return 0;
+    memset(pgdir, 0, PGSIZE);
+    if (P2V(PHYSTOP) > (void *) DEVSPACE)
+        panic("PHYSTOP too high");
+    for (k = kmap; k < &kmap[NUMBERofELEMENT(kmap)];
+    k++)
+    if (mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+                 (uint) k->phys_start, k->perm) < 0) {
+        freevm(pgdir);
+        return 0;
     }
-  return pgdir;
+    return pgdir;
 }
 
 // Allocate one page table for the machine for the kernel address
 // space for scheduler processes.
 void
-kvmalloc(void)
-{
-  kpgdir = setupkvm();
-  switchkvm();
+kvmalloc(void) {
+    kpgdir = setupkvm();
+    switchkvm();
 }
 
 // Switch h/w page table register to the kernel-only page table,
 // for when no process is running.
 void
-switchkvm(void)
-{
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+switchkvm(void) {
+    lcr3(V2P(kpgdir));   // switch to the kernel page table
 }
 
 // Switch TSS and h/w page table to correspond to process p.
 void
-switchuvm(struct proc *p)
-{
-  if(p == 0)
-    panic("switchuvm: no process");
-  if(p->kstack == 0)
-    panic("switchuvm: no kstack");
-  if(p->pgdir == 0)
-    panic("switchuvm: no pgdir");
-
-  pushcli();
-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-                                sizeof(mycpu()->ts)-1, 0);
-  mycpu()->gdt[SEG_TSS].s = 0;
-  mycpu()->ts.ss0 = SEG_KDATA << 3;
-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
-  // forbids I/O instructions (e.g., inb and outb) from user space
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
-  ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
-  popcli();
+switchuvm(struct proc *p) {
+    if (p == 0)
+        panic("switchuvm: no process");
+    if (p->kstack == 0)
+        panic("switchuvm: no kstack");
+    if (p->pgdir == 0)
+        panic("switchuvm: no pgdir");
+
+    pushcli();
+    mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+                                  sizeof(mycpu()->ts) - 1, 0);
+    mycpu()->gdt[SEG_TSS].s = 0;
+    mycpu()->ts.ss0 = SEG_KDATA << 3;
+    mycpu()->ts.esp0 = (uint) p->kstack + KSTACKSIZE;
+    // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+    // forbids I/O instructions (e.g., inb and outb) from user space
+    mycpu()->ts.iomb = (ushort) 0xFFFF;
+    ltr(SEG_TSS << 3);
+    lcr3(V2P(p->pgdir));  // switch to process's address space
+    popcli();
 }
 
 // Load the initcode into address 0 of pgdir.
 // sz must be less than a page.
 void
-inituvm(pde_t *pgdir, char *init, uint sz)
-{
-  char *mem;
-
-  if(sz >= PGSIZE)
-    panic("inituvm: more than a page");
-  mem = kalloc();
-  memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
-  memmove(mem, init, sz);
+inituvm(pde_t *pgdir, char *init, uint sz) {
+    char *mem;
+
+    if (sz >= PGSIZE)
+        panic("inituvm: more than a page");
+    mem = kalloc();
+    memset(mem, 0, PGSIZE);
+    mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W | PTE_U);
+    memmove(mem, init, sz);
 }
 
 // Load a program segment into pgdir.  addr must be page-aligned
 // and the pages from addr to addr+sz must already be mapped.
 int
-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
-{
-  uint i, pa, n;
-  pte_t *pte;
-
-  if((uint) addr % PGSIZE != 0)
-    panic("loaduvm: addr must be page aligned");
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
-      panic("loaduvm: address should exist");
-    pa = PTE_ADDR(*pte);
-    if(sz - i < PGSIZE)
-      n = sz - i;
-    else
-      n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
-      return -1;
-  }
-  return 0;
+loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz) {
+    uint i, pa, n;
+    pte_t *pte;
+
+    if ((uint) addr % PGSIZE != 0)
+        panic("loaduvm: addr must be page aligned");
+    for (i = 0; i < sz; i += PGSIZE) {
+        if ((pte = walkpgdir(pgdir, addr + i, 0)) == 0)
+            panic("loaduvm: address should exist");
+        pa = PTE_ADDR(*pte);
+        if (sz - i < PGSIZE)
+            n = sz - i;
+        else
+            n = PGSIZE;
+        if (readi(ip, P2V(pa), offset + i, n) != n)
+            return -1;
+    }
+    return 0;
 }
 
-// Allocate page tables and physical memory to grow process from oldsz to
-// newsz, which need not be page aligned.  Returns new size or 0 on error.
-int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
-  char *mem;
-  uint a;
+void fifoPageFinder(char *va) {
+    struct proc *curproc = myproc();
+    int i;
+    //TODO delete cprintf("rnp pid:%d count:%d va:0x%x\n", curproc->pid, curproc->pagesinmem, va);
+    for (i = 0; i < MAX_PSYC_PAGES; i++)
+        if (curproc->FREE_PAGES[i].va == (char *) 0xffffffff)
+            goto FOUND;
+    cprintf("panic follows, pid:%d, name:%s\n", curproc->pid, curproc->name);
+    panic("recordNewPage: no free pages");
+    FOUND:
+    curproc->FREE_PAGES[i].va = va;
+    curproc->FREE_PAGES[i].next = curproc->head;
+    curproc->head = &curproc->FREE_PAGES[i];
+}
 
-  if(newsz >= KERNBASE)
-    return 0;
-  if(newsz < oldsz)
-    return oldsz;
+void scPageFinder(char *va) {
+    struct proc *curproc = myproc();
+    int i;
+    //TODO delete cprintf("scRecord!\n");
+    for (i = 0; i < MAX_PSYC_PAGES; i++)
+        if (curproc->FREE_PAGES[i].va == (char *) 0xffffffff)
+            goto FOUND;
+    cprintf("panic follows, pid:%d, name:%s\n", curproc->pid, curproc->name);
+    panic("recordNewPage: no free pages");
+    FOUND:
+    //TODO delete cprintf("found unused page!\n");
+    curproc->FREE_PAGES[i].va = va;
+    curproc->FREE_PAGES[i].next = curproc->head;
+    curproc->FREE_PAGES[i].prev = 0;
+    if (curproc->head != 0)// old head points back to new head
+        curproc->head->prev = &curproc->FREE_PAGES[i];
+    else//head == 0 so first link inserted is also the tail
+        curproc->tail = &curproc->FREE_PAGES[i];
+    curproc->head = &curproc->FREE_PAGES[i];
+}
 
-  a = PGROUNDUP(oldsz);
-  for(; a < newsz; a += PGSIZE){
-    mem = kalloc();
-    if(mem == 0){
-      cprintf("allocuvm out of memory\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      return 0;
+void recordNewPage(char *va) {
+    //TODO delete $$$
+    struct proc *curproc = myproc();
+
+#if FIFO
+    //TODO cprintf("recordNewPage: %s is calling fifoRecord with: 0x%x\n", proc->name, va);
+    fifoPageFinder(va);
+#else
+
+#if SCFIFO
+    //TODO cprintf("recordNewPage: %s is calling scRecord with: 0x%x\n", curproc->name, va);
+    scPageFinder(va);
+#endif
+#endif
+
+    curproc->NUM_PAGES_IN_MEMORY++;
+    //TODO delete cprintf("\n++++++++++++++++++ curproc->pagesinmem+++++++++++++ : %d\n", curproc->pagesinmem);
+}
+
+struct freePage *fifoWrite() {
+    struct proc *curproc = myproc();
+    int i;
+    struct freePage *link, *l;
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        if (curproc->SWAPPED_PAGES[i].va == (char *) 0xffffffff)
+            goto FOUND;
     }
-    memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
-      cprintf("allocuvm out of memory (2)\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      kfree(mem);
-      return 0;
+    panic("writePageToSwapFile: FIFO no slot for swapped page");
+    FOUND:
+    link = curproc->head;
+    if (link == 0)
+        panic("fifoWrite: curproc->head is NULL");
+    if (link->next == 0)
+        panic("fifoWrite: single page in phys mem");
+    // find the before-last link in the used pages list
+    while (link->next->next != 0)
+        link = link->next;
+    l = link->next;
+    link->next = 0;
+
+
+    curproc->SWAPPED_PAGES[i].va = l->va;
+    int num = 0;
+    if ((num = writeToSwapFile(curproc, (char *) PTE_ADDR(l->va), i * PGSIZE, PGSIZE)) == 0)
+        return 0;
+
+    pte_t *pte1 = walkpgdir(curproc->pgdir, (void *) l->va, 0);
+    if (!*pte1)
+        panic("writePageToSwapFile: pte1 is empty");
+
+    kfree((char *) PTE_ADDR(P2V_WO(*walkpgdir(curproc->pgdir, l->va, 0))));
+    *pte1 = PTE_W | PTE_U | PTE_PG;
+    ++curproc->NUM_TOTAL_PAGED_OUT;
+    ++curproc->NUM_PAGES_IN_SWAP_FILE;
+
+    lcr3(V2P(curproc->pgdir));
+    return l;
+}
+
+int checkAccBit(char *va) {
+    struct proc *curproc = myproc();
+    uint accessed;
+    pte_t *pte = walkpgdir(curproc->pgdir, (void *) va, 0);
+    if (!*pte)
+        panic("checkAccBit: pte1 is empty");
+    accessed = (*pte) & PTE_A;
+    (*pte) &= ~PTE_A;
+    return accessed;
+}
+
+struct freePage *scWrite(char *va) {
+    struct proc *curproc = myproc();
+    //TODO delete  cprintf("scWrite: ");
+    int i;
+    struct freePage *mover, *oldTail;
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        if (curproc->SWAPPED_PAGES[i].va == (char *) 0xffffffff)
+            goto foundswappedpageslot;
     }
-  }
-  return newsz;
+    panic("writePageToSwapFile: FIFO no slot for swapped page");
+
+    foundswappedpageslot:
+    //link = curproc->head;
+    if (curproc->head == 0)
+        panic("scWrite: curproc->head is NULL");
+    if (curproc->head->next == 0)
+        panic("scWrite: single page in phys mem");
+
+    mover = curproc->tail;
+    oldTail = curproc->tail;// to avoid infinite loop if everyone was accessed
+    do {
+        //move mover from tail to head
+        curproc->tail = curproc->tail->prev;
+        curproc->tail->next = 0;
+        mover->prev = 0;
+        mover->next = curproc->head;
+        curproc->head->prev = mover;
+        curproc->head = mover;
+        mover = curproc->tail;
+    } while (checkAccBit(curproc->head->va) && mover != oldTail);
+
+
+    //make the swap
+    curproc->SWAPPED_PAGES[i].va = curproc->head->va;
+    int num = 0;
+    if ((num = writeToSwapFile(curproc, (char *) PTE_ADDR(curproc->head->va), i * PGSIZE, PGSIZE)) == 0)
+        return 0;
+
+    pte_t *pte1 = walkpgdir(curproc->pgdir, (void *) curproc->head->va, 0);
+    if (!*pte1)
+        panic("writePageToSwapFile: pte1 is empty");
+
+    kfree((char *) PTE_ADDR(P2V_WO(*walkpgdir(curproc->pgdir, curproc->head->va, 0))));
+    *pte1 = PTE_W | PTE_U | PTE_PG;
+    ++curproc->NUM_TOTAL_PAGED_OUT;
+    ++curproc->NUM_PAGES_IN_SWAP_FILE;
+
+    //TODO delete   cprintf("++curproc->pagesinswapfile : %d", curproc->pagesinswapfile);
+
+    lcr3(V2P(curproc->pgdir));
+    curproc->head->va = va;
+
+    //TODO cprintf("scWrite: new addr in head: 0x%x\n", va);
+
+    // unnecessary but will do for now
+    return curproc->head;
+}
+
+struct freePage *writePageToSwapFile(char *va) {
+    //TODO delete $$$
+
+#if FIFO
+    return fifoWrite();
+#else
+
+#if SCFIFO
+    //TODO cprintf("writePageToSwapFile: calling scWrite\n");
+  return scWrite(va);
+
+#endif
+#endif
+    //TODO: delete cprintf("none of the above...\n");
+    return 0;
+}
+
+
+// Allocate page tables and physical memory to grow process from oldsz to
+// newsz, which need not be page aligned.  Returns new size or 0 on error.
+int
+allocuvm(pde_t *pgdir, uint oldsz, uint newsz) {
+    char *mem;
+    uint a;
+    struct proc *curproc = myproc();
+
+    uint newpage = 1;
+    struct freePage *l;
+
+    if (newsz >= KERNBASE)
+        return 0;
+    if (newsz < oldsz)
+        return oldsz;
+
+    a = PGROUNDUP(oldsz);
+    for (; a < newsz; a += PGSIZE) {
+
+        //////////////////////////////////////
+        if (curproc->NUM_PAGES_IN_MEMORY >= MAX_PSYC_PAGES) {
+            // TODO delete cprintf("writing to swap file, curproc->name: %s, pagesinmem: %d\n", curproc->name, curproc->pagesinmem);
+
+            //TODO remove l! it doesn't belong here
+            if ((l = writePageToSwapFile((char *) a)) == 0)
+                panic("allocuvm: error writing page to swap file");
+
+            //TODO: these FIFO specific steps don't belong here!
+            // they should move to a FIFO specific functiom!
+#if FIFO
+            //TODO cprintf("allocuvm: FIFO's little part\n");
+            l->va = (char *) a;
+            l->next = curproc->head;
+            curproc->head = l;
+#endif
+
+            newpage = 0;
+        }
+
+        //////////////////////////////////
+
+        mem = kalloc();
+        if (mem == 0) {
+            cprintf("allocuvm out of memory\n");
+            deallocuvm(pgdir, newsz, oldsz);
+            return 0;
+        }
+
+        /////////////////
+        if (newpage) {
+            //TODO delete cprintf("nepage = 1");
+            //if(proc->pagesinmem >= 11)
+            //TODO delete cprintf("recorded new page, curproc->name: %s, pagesinmem: %d\n", curproc->name, proc->pagesinmem);
+            recordNewPage((char *) a);
+        }
+
+        //////////////////
+        memset(mem, 0, PGSIZE);
+        if (mappages(pgdir, (char *) a, PGSIZE, V2P(mem), PTE_W | PTE_U) < 0) {
+            cprintf("allocuvm out of memory (2)\n");
+            deallocuvm(pgdir, newsz, oldsz);
+            kfree(mem);
+            return 0;
+        }
+    }
+    return newsz;
 }
 
 // Deallocate user pages to bring the process size from oldsz to
@@ -253,142 +492,383 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 // need to be less than oldsz.  oldsz can be larger than the actual
 // process size.  Returns the new process size.
 int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
-  pte_t *pte;
-  uint a, pa;
-
-  if(newsz >= oldsz)
-    return oldsz;
-
-  a = PGROUNDUP(newsz);
-  for(; a  < oldsz; a += PGSIZE){
-    pte = walkpgdir(pgdir, (char*)a, 0);
-    if(!pte)
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
-      pa = PTE_ADDR(*pte);
-      if(pa == 0)
-        panic("kfree");
-      char *v = P2V(pa);
-      kfree(v);
-      *pte = 0;
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz) {
+    pte_t *pte;
+    uint a, pa;
+    int i;
+    struct proc *curproc = myproc();
+
+    if (newsz >= oldsz)
+        return oldsz;
+
+    a = PGROUNDUP(newsz);
+    for (; a < oldsz; a += PGSIZE) {
+        pte = walkpgdir(pgdir, (char *) a, 0);
+        if (!pte)
+            a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+        else if ((*pte & PTE_P) != 0) {
+            pa = PTE_ADDR(*pte);
+            if (pa == 0)
+                panic("kfree");
+
+////////////////////////////////////////////////////////////////
+
+            if (curproc->pgdir == pgdir) {
+                /*
+                The process itself is deallocating pages via sbrk() with a negative
+                argument. Update proc's data structure accordingly.
+                */
+
+                for (i = 0; i < MAX_PSYC_PAGES; i++) {
+                    if (curproc->FREE_PAGES[i].va == (char *) a)
+                        goto founddeallocuvmPTEP;
+                }
+
+                panic("deallocuvm: entry not found in curproc->freepages");
+                founddeallocuvmPTEP:
+                curproc->FREE_PAGES[i].va = (char *) 0xffffffff;
+#if FIFO
+                if (curproc->head == &curproc->FREE_PAGES[i])
+                    curproc->head = curproc->FREE_PAGES[i].next;
+                else {
+                    struct freePage *l = curproc->head;
+                    while (l->next != &curproc->FREE_PAGES[i])
+                        l = l->next;
+                    l->next = curproc->FREE_PAGES[i].next;
+                }
+                curproc->FREE_PAGES[i].next = 0;
+
+//#endif
+#elif SCFIFO
+                //TODO  cprintf("deallocuvm: entering SCFIFO part\n");
+
+        if (curproc->head == &curproc->freepages[i]){
+          curproc->head = curproc->freepages[i].next;
+          if(curproc->head != 0)
+            curproc->head->prev = 0;
+          goto doneLooking;
+        }
+        if (curproc->tail == &curproc->freepages[i]){
+          curproc->tail = curproc->freepages[i].prev;
+          if(curproc->tail != 0)// should allways be true but lets be extra safe...
+            curproc->tail->next = 0;
+          goto doneLooking;
+        }
+        struct freepg *l = curproc->head;
+        while (l->next != 0 && l->next != &curproc->freepages[i]){
+          l = l->next;
+        }
+        l->next = curproc->freepages[i].next;
+        if (curproc->freepages[i].next != 0){
+          curproc->freepages[i].next->prev = l;
+        }
+
+doneLooking:
+        //TODO delete cprintf("deallocCount = %d\n", ++deallocCount);
+        curproc->freepages[i].next = 0;
+        curproc->freepages[i].prev = 0;
+
+#endif
+
+                curproc->NUM_PAGES_IN_MEMORY--;
+            }
+            char *v = P2V(pa);
+
+////////////////////////////////////////////////////
+            kfree(v);
+            *pte = 0;
+        } else if (*pte & PTE_PG && curproc->pgdir == pgdir) {
+            /*
+            The process itself is deallocating pages via sbrk() with a negative
+            argument. Update proc's data structure accordingly.
+            */
+
+            for (i = 0; i < MAX_PSYC_PAGES; i++) {
+                if (curproc->SWAPPED_PAGES[i].va == (char *) a)
+                    goto founddeallocuvmPTEPG;
+            }
+            panic("deallocuvm: entry not found in curproc->swappedpages");
+            founddeallocuvmPTEPG:
+            curproc->SWAPPED_PAGES[i].va = (char *) 0xffffffff;
+            curproc->SWAPPED_PAGES[i].swaploc = 0;
+            curproc->NUM_PAGES_IN_SWAP_FILE--;
+        }
     }
-  }
-  return newsz;
+    return newsz;
 }
 
 // Free a page table and all the physical memory pages
 // in the user part.
 void
-freevm(pde_t *pgdir)
-{
-  uint i;
-
-  if(pgdir == 0)
-    panic("freevm: no pgdir");
-  deallocuvm(pgdir, KERNBASE, 0);
-  for(i = 0; i < NPDENTRIES; i++){
-    if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
-      kfree(v);
+freevm(pde_t *pgdir) {
+    uint i;
+
+    if (pgdir == 0)
+        panic("freevm: no pgdir");
+    deallocuvm(pgdir, KERNBASE, 0);
+    for (i = 0; i < NPDENTRIES; i++) {
+        if (pgdir[i] & PTE_P) {
+            char *v = P2V(PTE_ADDR(pgdir[i]));
+            kfree(v);
+        }
     }
-  }
-  kfree((char*)pgdir);
+    kfree((char *) pgdir);
 }
 
 // Clear PTE_U on a page. Used to create an inaccessible
 // page beneath the user stack.
 void
-clearpteu(pde_t *pgdir, char *uva)
-{
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-  if(pte == 0)
-    panic("clearpteu");
-  *pte &= ~PTE_U;
+clearpteu(pde_t *pgdir, char *uva) {
+    pte_t *pte;
+
+    pte = walkpgdir(pgdir, uva, 0);
+    if (pte == 0)
+        panic("clearpteu");
+    *pte &= ~PTE_U;
 }
 
 // Given a parent process's page table, create a copy
 // of it for a child.
-pde_t*
-copyuvm(pde_t *pgdir, uint sz)
-{
-  pde_t *d;
-  pte_t *pte;
-  uint pa, i, flags;
-  char *mem;
-
-  if((d = setupkvm()) == 0)
-    return 0;
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
-      panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
-      panic("copyuvm: page not present");
-    pa = PTE_ADDR(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-      kfree(mem);
-      goto bad;
+pde_t *
+copyuvm(pde_t *pgdir, uint sz) {
+    pde_t *d;
+    pte_t *pte;
+    uint pa, i, flags;
+    char *mem;
+
+    if ((d = setupkvm()) == 0)
+        return 0;
+    for (i = 0; i < sz; i += PGSIZE) {
+        if ((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+            panic("copyuvm: pte should exist");
+//        if (!(*pte & PTE_P))
+        if (!(*pte & PTE_P) && !(*pte & PTE_PG))
+            panic("copyuvm: page not present");
+
+        if (*pte & PTE_PG) {
+            // cprintf("copyuvm PTR_PG\n"); // TODO delete
+            pte = walkpgdir(d, (void *) i, 1);
+            *pte = PTE_U | PTE_W | PTE_PG;
+            continue;
+        }
+
+        pa = PTE_ADDR(*pte);
+        flags = PTE_FLAGS(*pte);
+        if ((mem = kalloc()) == 0)
+            goto bad;
+        memmove(mem, (char *) P2V(pa), PGSIZE);
+        if (mappages(d, (void *) i, PGSIZE, V2P(mem), flags) < 0) {
+            kfree(mem);
+            goto bad;
+        }
     }
-  }
-  return d;
+    return d;
 
-bad:
-  freevm(d);
-  return 0;
+    bad:
+    freevm(d);
+    return 0;
 }
 
 //PAGEBREAK!
 // Map user virtual address to kernel address.
-char*
-uva2ka(pde_t *pgdir, char *uva)
-{
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-  if((*pte & PTE_P) == 0)
-    return 0;
-  if((*pte & PTE_U) == 0)
-    return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
+char *
+uva2ka(pde_t *pgdir, char *uva) {
+    pte_t *pte;
+
+    pte = walkpgdir(pgdir, uva, 0);
+    if ((*pte & PTE_P) == 0)
+        return 0;
+    if ((*pte & PTE_U) == 0)
+        return 0;
+    return (char *) P2V(PTE_ADDR(*pte));
 }
 
 // Copy len bytes from p to user address va in page table pgdir.
 // Most useful when pgdir is not the current page table.
 // uva2ka ensures this only works for PTE_U pages.
 int
-copyout(pde_t *pgdir, uint va, void *p, uint len)
-{
-  char *buf, *pa0;
-  uint n, va0;
-
-  buf = (char*)p;
-  while(len > 0){
-    va0 = (uint)PGROUNDDOWN(va);
-    pa0 = uva2ka(pgdir, (char*)va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (va - va0);
-    if(n > len)
-      n = len;
-    memmove(pa0 + (va - va0), buf, n);
-    len -= n;
-    buf += n;
-    va = va0 + PGSIZE;
-  }
-  return 0;
+copyout(pde_t *pgdir, uint va, void *p, uint len) {
+    char *buf, *pa0;
+    uint n, va0;
+
+    buf = (char *) p;
+    while (len > 0) {
+        va0 = (uint) PGROUNDDOWN(va);
+        pa0 = uva2ka(pgdir, (char *) va0);
+        if (pa0 == 0)
+            return -1;
+        n = PGSIZE - (va - va0);
+        if (n > len)
+            n = len;
+        memmove(pa0 + (va - va0), buf, n);
+        len -= n;
+        buf += n;
+        va = va0 + PGSIZE;
+    }
+    return 0;
 }
 
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
+void fifoSwap(uint addr) {
+    struct proc *curproc = myproc();
+    int i, j;
+    char buf[BUF_SIZE];
+    pte_t *pte1, *pte2;
+
+    struct freePage *link = curproc->head;
+    struct freePage *l;
+    if (link == 0)
+        panic("fifoSwap: curproc->head is NULL");
+    if (link->next == 0)
+        panic("fifoSwap: single page in phys mem");
+    // find the before-last link in the used pages list
+    while (link->next->next != 0)
+        link = link->next;
+    l = link->next;
+    link->next = 0;
+
+    if (DEBUG) {
+        //cprintf("\naddress between 0x%x and 0x%x was accessed but was on disk.\n", addr, addr+PGSIZE);
+        cprintf("FIFO chose to page out page starting at 0x%x \n\n", l->va);
+    }
+
+    //find the address of the page table entry to copy into the swap file
+    pte1 = walkpgdir(curproc->pgdir, (void *) l->va, 0);
+    if (!*pte1)
+        panic("swapFile: FIFO pte1 is empty");
+    //find a swap file page descriptor slot
+    for (i = 0; i < MAX_PSYC_PAGES; i++)
+        if (curproc->SWAPPED_PAGES[i].va == (char *) PTE_ADDR(addr))
+            goto foundswappedslot;
+    panic("swappages");
+    foundswappedslot:
+    //update relevant fields in proc
+    // curproc->swappedpages[i].va = (char*)P2V_WO(PTE_ADDR(*pte1)); // WRONG!!!
+    curproc->SWAPPED_PAGES[i].va = l->va;
+    //assign the physical page to addr in the relevant page table
+    pte2 = walkpgdir(curproc->pgdir, (void *) addr, 0);
+    if (!*pte2)
+        panic("swapFile: FIFO pte2 is empty");
+    //set page table entry
+    *pte2 = PTE_ADDR(*pte1) | PTE_U | PTE_W | PTE_P;
+    for (j = 0; j < 4; j++) {
+        int loc = (i * PGSIZE) + ((PGSIZE / 4) * j);
+        // cprintf("i:%d j:%d loc:0x%x\n", i,j,loc);//TODO delete
+        int addroffset = ((PGSIZE / 4) * j);
+        // int read, written;
+        memset(buf, 0, BUF_SIZE);
+        //copy the new page from the swap file to buf
+        // read =
+        readFromSwapFile(curproc, buf, loc, BUF_SIZE);
+        // cprintf("read:%d\n", read);//TODO delete
+        //copy the old page from the memory to the swap file
+        //written =
+        writeToSwapFile(curproc, (char *) (P2V_WO(PTE_ADDR(*pte1)) + addroffset), loc, BUF_SIZE);
+        // cprintf("written:%d\n", written);//TODO delete
+        //copy the new page from buf to the memory
+        memmove((void *) (PTE_ADDR(addr) + addroffset), (void *) buf, BUF_SIZE);
+    }
+    //update the page table entry flags, reset the physical page address
+    *pte1 = PTE_U | PTE_W | PTE_PG;
+    //update l to hold the new va
+    l->next = curproc->head;
+    curproc->head = l;
+    l->va = (char *) PTE_ADDR(addr);
+}
+
+
+void moveByChunk(int i, char buf[], struct proc *curproc, pte_t *pte1, uint addr){
+    int j;
+    for (j = 0; j < 4; j++) {
+        int loc = (i * PGSIZE) + ((PGSIZE / 4) * j);
+        int addroffset = ((PGSIZE / 4) * j);
+        memset(buf, 0, BUF_SIZE);
+        readFromSwapFile(curproc, buf, loc, BUF_SIZE);
+        writeToSwapFile(curproc, (char *) (P2V_WO(PTE_ADDR(*pte1)) + addroffset), loc, BUF_SIZE);
+        memmove((void *) (PTE_ADDR(addr) + addroffset), (void *) buf, BUF_SIZE);
+    }
+}
+
+
+void scSwap(uint addr) {
+    struct proc *curproc = myproc();
+    int i, j;
+    char buf[BUF_SIZE];
+    pte_t *pte1, *pte2;
+    struct freePage *mover, *oldTail;
+
+    if (curproc->head == 0)
+        panic("scSwap: curproc->head is NULL");
+    if (curproc->head->next == 0)
+        panic("scSwap: single page in phys mem");
+
+    mover = curproc->tail;
+    oldTail = curproc->tail;// to avoid infinite loop if somehow everyone was accessed
+    do {
+        //move mover from tail to head
+        curproc->tail = curproc->tail->prev;
+        curproc->tail->next = 0;
+        mover->prev = 0;
+        mover->next = curproc->head;
+        curproc->head->prev = mover;
+        curproc->head = mover;
+        mover = curproc->tail;
+    } while (checkAccBit(curproc->head->va) && mover != oldTail);
+
+    if (DEBUG) {
+        //cprintf("\naddress between 0x%x and 0x%x was accessed but was on disk.\n", addr, addr+PGSIZE);
+        cprintf("SCFIFO chose to page out page starting at 0x%x \n\n", curproc->head->va);
+    }
+
+    //find the address of the page table entry to copy into the swap file
+    pte1 = walkpgdir(curproc->pgdir, (void *) curproc->head->va, 0);
+    if (!*pte1)
+        panic("swapFile: SCFIFO pte1 is empty");
+
+    //find a swap file page descriptor slot
+    for (i = 0; i < MAX_PSYC_PAGES; i++) {
+        if (curproc->SWAPPED_PAGES[i].va == (char *) PTE_ADDR(addr))
+            goto foundswappedpageslot;
+    }
+    panic("scSwap: SCFIFO no slot for swapped page");
+
+    foundswappedpageslot:
+
+    curproc->SWAPPED_PAGES[i].va = curproc->head->va;
+    //assign the physical page to addr in the relevant page table
+    pte2 = walkpgdir(curproc->pgdir, (void *) addr, 0);
+    if (!*pte2)
+        panic("swapFile: SCFIFO pte2 is empty");
+    //set page table entry
+    //TODO verify we're not setting PTE_U where we shouldn't be...
+    *pte2 = PTE_ADDR(*pte1) | PTE_U | PTE_W | PTE_P;// access bit is zeroed...
+
+    moveByChunk(i, buf, curproc, pte1, addr);
 
+    *pte1 = PTE_U | PTE_W | PTE_PG;
+
+    curproc->head->va = (char *) PTE_ADDR(addr);
+
+}
+
+void pageSwap(uint addr) {
+    struct proc *curproc = myproc();
+    //TODO delet   cprintf("resched swapPages!\n");
+    if (strncmp(curproc->name, "init", 4) == 0 || strncmp(curproc->name, "sh", 2) == 0) {
+        curproc->NUM_PAGES_IN_MEMORY++;
+        return;
+    }
+
+#if FIFO
+    fifoSwap(addr);
+#else
+
+#if SCFIFO
+    //cprintf("swapPages: calling scSwap\n");
+    scSwap(addr);
+
+#endif
+#endif
+    lcr3(V2P(curproc->pgdir));
+
+    ++curproc->NUM_TOTAL_PAGED_OUT;
+}
